---
title: "Working with data in Julia"
description: "Part two of a three-part series on Julia, in which the author teaches herself the basics of wrangling rectangular data in Julia"
date: "2024-03-02"
categories: ["Julia", "Data Wrangling"]
jupyter: julia-1.10
--- 

```{julia}
#| include: false
using Pkg
Pkg.activate("sandbox");
```

<!--------------- post begins here ----------------->




::: {.column-margin}

![[Mass Effect 1](https://www.deviantart.com/lagota/art/Mass-Effect-1-Final-Poster-295106207). By user [lagota](https://www.deviantart.com/lagota) on Deviant Art, released under a CC-BY-NC-ND licence.](mass-effect-1.jpg){fig-alt="Reimagined Mass Effect 1 cover showing the Normandy departing the Citadel"}

:::

## Data frames I

Unlike R, Julia doesn't come with a native class to represent data frames. Instead, there is the DataFrames package which provides the functionality needed to represent tabular data. The `DataFrame()` function allows you to manually construct a data frame, with a syntax that feels very familiar to an R user. Vectors passed as inputs to `DataFrame()` must all have one element for every row in the data frame, or else be length one. So I could construct a small data frame listing the novels from William Gibson's "Sprawl" trilogy like this:

```{julia}
using DataFrames

sprawl = DataFrame(
  title = ["Neuromancer", "Count Zero", "Mona Lisa Overdrive"],
  published = [1984, 1986, 1988], 
  author = "William Gibson"
)
```

Data frames have pretty print methods so the output looks quite nice here. But internally it's essentially a collection of vectors, one for each column. For example, `sprawl.title` is a vector of three strings:

```{julia}
sprawl.title
```

In real life though, you don't usually construct a data frame manually. It's more typical to import a data frame from a CSV file or similar. To that end, we can take advantage of the CSV package to read data from a data file:

```{julia}
using CSV
starwars_csv = CSV.File("starwars.csv"; missingstring = "NA");
```

This `starwars_csv` object isn't a data frame yet, it's an object of type CSV.file. Data frames are *columnar* data structures (i.e., a collection of vectors, one per column), whereas a CSV.file is a *rowwise* data structure (i.e., a collection of CSV.row objects, one per row). We can see this by taking a look at the first element in the `starwars_csv` object:

```{julia}
starwars_csv[1]
```

To convert this to a DataFrame object, we simply pass it to `DataFrame()`:

```{julia}
starwars = DataFrame(starwars_csv)
```

The core tools for working with data frames in Julia feel quite familiar coming from either Matlab or R. You can subset a data frame by passing it numeric indices, for instance:

```{julia}
starwars[1:6, 1:5]
```

However, there are other methods for subsetting a data frame. You can also filter the rows of a data frame using logical expressions. Again, this is quite similar to how it works in base R. For instance, I can construct a boolean vector `fair_skinned` which indicates whether the corresponding row in `starwars` refers to a person with fair skin:^[As an aside, notice that I've used `.==` rather than `==` as the equality test. This is because `==` is a scalar operator: it doesn't work for vectors unless you broadcast it using `.`]

```{julia}
fair_skinned = starwars.skin_color .== "fair";
```

Now that I have these indices, I can create a subset of the data frame containing only those rows referring to fair skinned person (or robot, or...)

```{julia}
starwars[fair_skinned, 1:5]
```

On the columns side, we also have more flexible options for subsetting a data frame. For example, instead of referring to columns using numerical indices, we can select the variables that we want to keep using their names:

```{julia}
starwars[1:6, [:name, :gender, :homeworld]]
```

This syntax is worth unpacking slightly, so I'll digress slightly to talk about...

## Symbols

Looking at the syntax in the last code cell, it's fairly clear that `[:name, :gender, :homeworld]` is a vector of three... somethings, but it's not immediately obvious what `:name` actually is. Much like R (and also inherited from Lisp) Julia has extensive [Metaprogramming](https://docs.julialang.org/en/v1/manual/metaprogramming/) capabilities because it has the ability to represent Julia code as data structures within the language itself. In the simplest case, we have [Symbols](https://docs.julialang.org/en/v1/base/base/#Core.Symbol) like `:name`, which are constructed using the quotation operator `:` and used to represent object names. So as you can see, `:name` is an object of type Symbol:

```{julia}
typeof(:name)
```

Symbols can be assigned to variables, and those variables can be used as part of expressions to be evaluated. In the code below I create a variable `colname` that stores the symbolic representation of a column name that I can invoke later:

```{julia}
colname = :title
```

As a simple example of how symbols can be used in practice, here's a Julia implementation of something like the `pull()` function in the R package dplyr, which allows the user to extract a single column from a data frame:

```{julia}
function pull(data::DataFrame, column::Symbol)
  getproperty(data, column)
end;
```

In this code I'm using the `getproperty()` function to do the same job that the `.` operator would do in an expression like `sprawl.title`. So here it is in action:

```{julia}
pull(sprawl, :title)
```

At the moment this `pull()` function isn't very useful at all -- `pull(sprawl, :title)` is really not an improvement on `sprawl.title` -- but a little bit later when I get around to talking about pipes in Julia it will potentially more valuable.


::: {.column-margin}

![[Mass Effect 2](https://www.deviantart.com/lagota/art/Mass-Effect-2-Final-Poster-294884760). By user [lagota](https://www.deviantart.com/lagota) on Deviant Art, released under a CC-BY-NC-ND licence.](mass-effect-2.jpg){fig-alt="Reimagined Mass Effect 2 cover showing the Normandy attacked by a Collector ship"}

:::


## Data frames II

Anyway, getting back on track, the key thing to realise is that when I wrote `[:name, :gender, :homeworld]` earlier what I was really doing is constructing a vector of symbols, and it's those symbols that I was using to select the columns that I wanted to retain. The DataFrames package also supplies a various selector functions that can be used to extract a subset of the columns. For example, `Not()` will select every column except the ones that are passed to `Not()`. So if I want to drop the hair color, eye color, sex, and homeworld columns, I could do this:

```{julia}
starwars[1:6, Not([:hair_color, :eye_color, :sex, :homeworld])]
```

The `Between()` selector does what you'd think. It returns all columns in between two named columns:

```{julia}
starwars[1:6, Between(:sex, :homeworld)]
```

There's also an `All()` selector that returns all columns, but that's not super exciting. More interesting, I think, is the `Cols()` selector which takes a predicate function as input.^[In this context, a predicate function is just one that returns `true` or `false`.] The column names are passed to the function, and they are included in the output if that function returns `true`. So, for example, if I want to extract the columns in the data whose name ends in `"color"` I can do this: 

```{julia}
starwars[1:6, Cols(x -> endswith(x, "color"))]
```



::: {.column-margin}

![[Mass Effect 3](https://www.deviantart.com/lagota/art/Mass-Effect-3-Final-Poster-290367120). By user [lagota](https://www.deviantart.com/lagota) on Deviant Art, released under a CC-BY-NC-ND licence.](mass-effect-3.jpg){fig-alt="Reimagined Mass Effect 3 cover showing the Normandy facing a fleet fo reapers"}

:::

## Data frames III

```{julia}
combine(groupby(starwars, :gender), :mass => rand) 
```

```{julia}
starwars |>
  d -> groupby(d, :gender) |>
  d -> combine(d, :mass => rand)
```

```{julia}
starwars |>
  d -> subset(d, :skin_color => x -> x.=="fair") |>
  d -> pull(d, :name)
```


## Image credit

All the lovely Mass Effect images in this post are from [lagota](https://www.deviantart.com/lagota) on DeviantArt, and are released under a CC-BY-NC-ND licence.

<!-- https://www.deviantart.com/lagota/art/The-illusive-man-306521415 -->
![](illusive-man.png)










