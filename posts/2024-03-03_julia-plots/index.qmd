---
title: "Plotting data in Julia"
description: "Part three of this three-part series of Julia posts, in which I try to figure out how to draw some nice plots"
date: "2024-03-03"
categories: ["Julia", "Data Visualisation"]
jupyter: julia-1.10
--- 

<!--------------- post begins here ----------------->


And so we come to the third post in my extremely ill-considered foray into learning Julia. In the [first part](/posts/2024-03-01_julia-foundation/) of the series I taught myself some of the foundations for writing Julia code, in the [second part](/posts/2024-03-02_julia-data-frames/) I discussed data wrangling in Julia, and so in the third and -- dear god in heaven please -- last of them, I'll take a look at data visualisation using the [Plots](https://docs.juliaplots.org/latest/) package, and using [PalmerPenguins](https://juliapackages.com/p/palmerpenguins) as my data set.

It will be brief this time, right? Right????


::: {.column-margin}

![Olaf Stapledon. See, it's a Penguin science fiction book so it keeps to the penguins theme of this post and the sci-fi theme of the series. I'm soooooo clever](olaf-stapledon.jpg){fig-alt="Cover of 'Olaf Stapledon'"}

:::

## Penguins data

It is hardly a deep insight to say this, but if you're going to play around with data visualisation tools it does help somewhat to have some data that you can plot. In the last post I pretty much exhausted my ability to look at the *Star Wars* data set that comes bundled in with the dplyr R package, so I'm picked something different this time. For no particular reason I decided to go with the *Palmer Penguins* data set that also exists in R, and has a Julia package in [PalmerPenguins](https://juliapackages.com/p/palmerpenguins). However, due to a painful little episode part way through writing all these posts I mistakenly decided that the PalmerPenguins package was causing me problems in the context of this quarto blog post (it wasn't... the actual problem was that I had my Julia environment configured incorrectly), so instead I ended up writing a copy of the data to a CSV file and used that instead. Sigh.

Okay, let's start by loading the packages I'll need for this post:


```{julia}
using CSV
using DataFrames
using Plots
using StatsPlots
```

Amazing. Thrilling. Et cetera. Now that we're all overwhelmed by the feeling of rising anticipation, let's load the data set from the CSV file:

```{julia}
penguins = DataFrame(CSV.File("penguins.csv"; missingstring = "NA")) 
```

Indeed, that is a lot of penguins. Precisely what I was looking for. I have some data, now I can start drawing some plots.



::: {.column-margin}

![The Handmaids Tale, because obviously what every queer person and woman wants to be thinking about in 2024 is what's probably going to happen to us in the near future](handmaids-tale.jpg){fig-alt="Cover of 'The Handmaids Tale'"}

:::


## Scatter plots

As you might imagine, there's more than one way you can go about constructing a data visualisation in Julia. For example, there's the [AlgebraOfGraphics](https://aog.makie.org/stable/) system that appears share some design philosophy with the ggplot2 package in R. That might have been a better choice for me to explore, but for whatever reason^[Honestly, at this point I don't even *know* why I'm making the choices I'm making in this increasingly-unhinged series of posts] I chose instead to explore the [Plots](https://docs.juliaplots.org/latest/) package and its extension package [StatsPlots](https://docs.juliaplots.org/dev/generated/statsplots/).

The impression I get from playing around with Plots/StatsPlots is that its design has more in common with the base graphics system in R than with ggplot2. There's a generic function `plot()` that you can use to construct plots, and lots of more specific functions that are essentially wrappers to `plot()`. For example, I'm going to start by drawing a scatter plot. I could use the wrapper function `scatter()` for this purposes, but you don't actually need to do this because it's effectively the same thing as calling `plot()` with different defaults. For learning purposes I find it helpful to understand what the different arguments to `plot()` actually do, so I'll avoid using the convenience functions here. 

Okay, so here's a simple scatter plot that plots the bill length of each penguin against the bill depth:

```{julia}
plot(
  penguins.bill_length_mm, 
  penguins.bill_depth_mm, 
  seriestype=:scatter,
  size=(500,500)
)
```

In this code chunk, the first argument specifies the variable to be plotted on the x-axis and the second specifies the variable to be plotted on the y-axis. No surprises there. The key thing to note is that in the later arguments I've specified two [plot attributes](https://docs.juliaplots.org/latest/generated/attributes_plot/). The `seriestype` attribute is what gives me a scatter plot (each observation is plotted with a single discrete plot marker), whereas the `size` attribute is used to control the size of the image produced in the output (in pixels).

Cool. Well, I can definitely draw something. That feels like a win.


## Using the `@df` macro

It's little awkward to refer to the `penguins` data frame repeatedly in this code, and so it's more convenient to use the `@df` macro:

```{julia}
@df penguins plot(
  :bill_length_mm,
  :bill_depth_mm,
  seriestype=:scatter,
  group=:species,
  size=(500,500)
)
```

Adding labels is achieved by modifying the relevant attributes:

```{julia}
@df penguins plot(
  :bill_length_mm,
  :bill_depth_mm,
  seriestype=:scatter,
  group=:species,
  title="Palmer Penguins",
  xlabel="Bill Length (mm)",
  ylabel="Bill Depth (mm)",
  size=(500,500)
)
```




::: {.column-margin}

![The Day of the Triffids. Well, it's more optimistic than Handmaids Tale I guess](day-of-the-triffids.jpg){fig-alt="Cover of 'The Day of the Triffids'"}

:::


## Macros

Siiiiiiigh. Okay, I used a macro. Better take a quick look at how the hell those work, right? 



::: {.column-margin}

![The Earthsea Quartet. Much better!](earthsea.jpg){fig-alt="Cover of 'Earthsea: The First Four Books'"}

:::

## Violin plots

Filter rows that have missing bill lengths, because violin series can't handle missing values. Then we can create a violin plot

```{julia}
bill_lengths = penguins |> 
  d -> subset(d, :bill_length_mm => b -> .!ismissing.(b)) |>
  d -> select(d, [:species, :bill_length_mm])

@df bill_lengths plot(
  string.(:species),
  :bill_length_mm,
  seriestype=:violin,
  legend=false,
  xlabel="Species",
  ylabel="Bill Length (mm)",
  size=(500,500)
)
```


::: {.column-margin}

![A science fiction omnibus. Yes I was getting lazy at this point](omnibus.jpg){fig-alt="Cover of 'Science Fiction Omnibus'"}

:::



