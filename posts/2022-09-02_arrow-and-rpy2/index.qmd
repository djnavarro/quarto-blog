---
title: "Passing Arrow data between Python and R with rpy2"
description: "Part two of the data-sharing post. An approach to sharing Arrow Tables between R and Python, using the rpy2 Python module in place of the reticulate R package. The same goal is achieved, using a slightly more Pythonic toolkit"
date: "2022-09-02"
categories: [Apache Arrow, R, Python]
image: "img/cover.jpg"
jupyter: python3
---

<!-- 
cover img: https://unsplash.com/photos/C4sxVxcXEQg
artist: Reuben Juarez
licence: unsplash free-to-use 
-->

<!-- 
# bash commands to build this post
conda activate continuation
cd ~/GitHub/sites/quarto-blog/posts/2022-09-02_arrow-and-rpy2
quarto render index.qmd --execute-daemon-restart
-->

> Me: I'm tired I don't wanna write my blog post you do it <br>
> 12yo: no <br>
> Me: pleeeeeeease? you just have to show people how to hand an Arrow Table from Python to R with rpy2 it's just a smol post <br>
> 12yo: I don't know what that is <br>
> 9yo: also that's child labour <br>
> &nbsp; &nbsp; -- my children, showing good personal boundaries

In the [last post on this blog](/posts/2022-09-01_reticulated-arrow/) I showed how Apache Arrow makes it possible to hand over data sets from R to Python (and vice versa) without making wasteful copies of the data. 

The solution I outlined there was to use the [reticulate](https://rstudio.github.io/reticulate/) package to conduct the handover, and rely on Arrow tools both sides to manage the data. In one sense it's a perfectly good solution to the problem... but it's a solution tailor made for R users who need access to Python. When viewed from the perspective of a Python user who needs access to R, it's a little awkward to have an R package (reticulate) governing the handover.^[Relatedly, if you're a Python user blogging in quarto, you are very unlikely to be using the [knitr engine](https://quarto.org/docs/reference/cells/cells-knitr.html) to execute code like I did in the last blog post. Instead you're almost certainly using the [jupyter engine](https://quarto.org/docs/reference/cells/cells-jupyter.html). With that in mind, and with the goal of making this post a little more Pythonic, I'm using Jupyter this time.] Perhaps we can find a more Pythonic way to approach this?

A solution to our problem is provided by the [rpy2 module](https://rpy2.github.io/) that provides an interface to R from Python, and the [rpy2-arrow extension module](https://rpy2.github.io/rpy2-arrow/version/main/html/index.html) that allows it to support Arrow objects. Let's take a look, shall we?

## Setting up the Python environment

For the purposes of this post I'll create a fresh conda environment that I'll call "continuation", both because this post is a continuation of the previous one and because the data set I'll use later is called [To Be Continued](https://cdhrdatasys.anu.edu.au/tobecontinued/). I was able install most packages I need through conda-forge, but for rpy2 and rpy2-arrow I was only able to do so from pypi so I had to use pip for that. So the code for setting up my Python environment was as follows:

``` bash
conda create -n continuation
conda install -n continuation pip pyarrow pandas jupyter
conda activate continuation
pip install rpy2 rpy2-arrow
```


## Introducing rpy2

The purpose of the rpy2 library is to allow users to call R from Python, typically with the goal of allowing access to statistical packages distributed through CRAN. I'm currently using version 3.5.4, and while this blog post won't even come close to documenting the full power of the library, the [rpy2 documentation](https://rpy2.github.io/doc/v3.5.x/html/index.html#) is quite extensive. To give you a bit of a flavour of it, let's import the module:

```{python import-rpy2}
import rpy2
rpy2.__version__
```

This does not in itself give us access to R. In order to call R code rpy2 needs to start R as a child process, and that doesn't happen until we import `rpy2.robjects`:

```{python import-robjects}
import rpy2.robjects as robjects
```

You'll notice that this prints a little startup message. If you're following along at home you'll probably see something different: you're most likely to see the typical R startup message. The only reason it's truncated on my machine is that I've modified my `.Rprofile` so that R is less chatty on start up. Also I added a pretty little rainbow because why not?^[As an aside, it's worth noting that rpy2 has run R with my standard configuration. It hasn't loaded any specific environment. I was half tempted to talk about how you a Python user could use rpy2 to configure the R environment using the [renv](https://rstudio.github.io/renv/index.html) package for instance, but that felt a little beyond the scope of the post. The only thing I will mention is that in this particular use case (passing Arrow objects between R and Python) I would not recommend trying to configure the Python environment and the R environment within the same conda environment. I tried this and oh my... the number of unsolvable conflicts was truly impressive. Keep the Python environment and the R environment separate babes.] Normally you'd see a more verbose startup message from R but I prefer to keep mine quieter so all it does is print the version string and a pretty little rainbow. 

Anyway, our next step is to load some packages. In native R code we'd use the `library()` function for this, but rpy2 provides a more Pythonic approach. Importing the packages submodule gives us acces to `importr()`, which is allows us to load packages. The code below illustrates how you can expose the base R package and the utils R package (both of which come bundled with any minimal R installation) to Python:

```{python import rpackages}
import rpy2.robjects.packages as rpackages

base = rpackages.importr("base")
utils = rpackages.importr("utils")
```

Of particular note is that once we have access to utils we can call the native R function `install.packages()` to install additional packages from CRAN. However, at this point we need to talk a little about how names are translated by rpy2. As every Python user would note, the dot is special and not used within the name of a function. Though not generally recommended in R except in special circumstances,^[The dot is typically used to denote an [S3](https://adv-r.hadley.nz/s3.html) method in R, but because R embraces chaos this is not universally adhered to and in any case S3 is... look, I love S3 but as Hadley Wickham once observed it's an object oriented programming system that absolutely allows you to shoot yourself in the foot if you want to. Anyway. This is not the post for ramblings about the chaotic splendour of R.] functions containing dots (and various other characters not permitted by Python) are syntactically valid in R. To address this, rpy2 will automatically convert dots to underscores. So if I want to install the fortunes package -- a toy package that contains various quotes vaguely related to R -- using rpy, this is how I'd do it:^[Depending on how blank your R configuration is, you may need to specify which CRAN mirror you want to download the package from before attempting the installation. To do that, include a command like `utils.chooseCRANmirror(ind=1)` to select the first mirror on the list of known servers.]

``` python
utils.install_packages("fortunes")
```

Once installed the fortunes package can be imported, allowing me to call the `fortune()` function from the package:

```{python use-fortunes}
fortunes = rpackages.importr("fortunes")
fortune = fortunes.fortune(7)
print(fortune)
```

I'm rather fond of this quote, and it seems very appropriate to the spirit underpinning polyglot data science. Whatever language or tools we're working in, we've usually chosen them for good reason.^[Seriously. Few things in life annoy me more than "language wars". Digging your heels in over the perceived superiority of your preferred tool is rarely a useful way to spend your time.] Sometimes though, we need access to something very different, and we want our tools to be able to talk fluently to each other.

In any case, although we've barely scratched the surface of what rpy2 is capable of, we're now at the point where we can start tackling the problem of transferring data from Python to R. To do that, however, we'll need some data.

## About the data 

The data set for this post comes from the [To Be Continued](https://cdhrdatasys.anu.edu.au/tobecontinued/) database of fiction published in Australian newspapers during the 19th and early 20th century. Originally collected using the incredibly cool [Trove](https://trove.nla.gov.au/) resource run by the National Library of Australia, it's released under a CC-BY-4.0 licence and maintained by Katherine Bode and Carol Hetherington. To get a sense of what the data looks like, let's use pandas to load the data set and inspect the first few rows:

```{python panda-read-csv}
import pandas

fiction = pandas.read_csv("fiction.csv", low_memory = False)
fiction.head()
```

We can take a look at the distribution of nationalities among published authors too. The table below counts the number of distinct publications (Trove IDs) and authors for each nationality represented in the data:

```{python panda-aggregate}
fiction[["Nationality", "Trove ID", "Publication Author"]]. \
  groupby("Nationality"). \
  nunique()
```

Now that we have a sense of the data, let's add Arrow to the mix!

## Panda to Arrow Table

I'm relatively new to working with Arrow data on the Python side, but I'm pleased to discover that it's straightforward to construct an Arrow Table from a Pandas DataFrame using pyarrow. Here's how we do that:
 
```{python arrow-fiction}
import pyarrow

pyarrow_fiction = pyarrow.Table.from_pandas(fiction)
pyarrow_fiction
```

The output looks about right to me. It's formatted slightly differently from what I expect when I'm working with Arrow Tables in R, but this is most definitely an Arrow Table, displayed according to pyarrow conventions. 

Now that we have our data represented as an Arrow Table, we can move onto the really fun part... seamlessly handing the reins back and forth between Python and R without ever making copies of the data object. 

## Passing Tables from Python to R

This is done with the [rpy2-arrow module](https://rpy2.github.io/rpy2-arrow/version/main/html/index.html)

```{python use-rpy2-arrow}
import rpy2_arrow.pyarrow_rarrow as pyra

rarrow_fiction = pyra.pyarrow_to_r_table(pyarrow_fiction)
rarrow_fiction
```

## Calling R code 

```{python py-dplyr}
%load_ext rpy2.ipython
```

```{python call-r}
%%R
suppressMessages({
  library(dplyr)
  library(arrow)
})
```

```{python more-r, results='asis'}
%%R -i rarrow_fiction
gender <- rarrow_fiction |> 
  count(Gender, Nationality) |>
  arrange(desc(n)) |>
  compute()
  
gender
```


## Passing Tables from R to Python

Earlier we imported `robjects` to start the embedded R session. We can access the R objects using `robjects.r`. For example:

```{python return-r-to-python}
r_gender = robjects.r('gender')
r_gender
```

Note that the `r_gender` variable refers to the Arrow Table in R. It's not a pyarrow table. We can use pyra to make the converson:

```{python convert-gender}
py_gender = pyra.rarrow_to_py_table(r_gender)
py_gender
```

## Back to Pandas

If we really want to, we can now convert this back to a Pandas DataFrame

```{python pygender-to-panda}
panda_gender = pyarrow.Table.to_pandas(py_gender)
panda_gender
```

## Acknowledgements {.appendix}

In writing this post I am heavily indebted to Isabella Velásquez, whose fabulous post on [calling R from Python with rpy2](https://rviews.rstudio.com/2022/05/25/calling-r-from-python-with-rpy2/) helped me immensely. The [documentation on integrating PyArrow with R](https://arrow.apache.org/docs/python/integration/python_r.html) was extremely helpful too!

