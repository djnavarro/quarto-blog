---
title: "Playing around with WebR"
author:
  - name: Danielle Navarro
    url: https://djnavarro.net
    affiliation: I'm on smoko
    affiliation-url: https://www.youtube.com/watch?v=j58V2vC9EPc
    orcid: 0000-0001-7648-6578
description: "playing with webr"
date: "2023-04-09"
categories: [R, WebR]
image: automaton1.png
---

<!--------------- my typical setup ----------------->

```{r setup, include=FALSE}
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
```

<!--------------- post begins here ----------------->

I made a little cellular automaton using webr: [webr-automata.djnavarro.net](https://webr-automata.djnavarro.net/). The source code is on github at [https://github.com/djnavarro/webr-automata](https://github.com/djnavarro/webr-automata)

:::{.column-screen-inset}
:::{layout-ncol=3} 

![](automaton1.png)

![](automaton2.png)

![](automaton3.png)

:::
:::

## The R code

It's built around an R function called `automaton()`:

```{r}
automaton <- function(str = NULL,
                      linebreak = "<br>",
                      n_rows = 30,
                      n_cols = 50,
                      iterations = 100,
                      symbols = c("░", "▒", "▓", "█")) {

  # create random string if none is given
  if (is.null(str)) {
    str <- sample(symbols, n_rows * n_cols, TRUE)
    str <- paste(str, collapse = "")
  }

  # make matrix from (possibly break-delimited) string
  str <- gsub(
    pattern = linebreak,
    replacement = "",
    x = str,
    fixed = TRUE
  )
  dat <- matrix(
    data = strsplit(str, "")[[1]],
    nrow = n_rows,
    ncol = n_cols,
    byrow = TRUE
  )

  # run simple automaton
  for (i in 1:iterations) {
    r <- sample(2:(n_rows - 1), 1)
    c <- sample(2:(n_cols - 1), 1)
    h <- sample(-1:1, 1)
    v <- sample(-1:1, 1)
    dat[r + v, c + h] <- dat[r, c]
  }

  # convert matrix to string and return
  str <- ""
  for (i in 1:n_rows) {
    row <- paste(dat[i, ], collapse = "")
    str <- paste(str, row, sep = linebreak)
  }
  str <- paste(str, linebreak, sep = "")
  str
}
```

Here's what it does:

```{r}
set.seed(1)
str <- automaton(
  linebreak = "\n", 
  n_rows = 20,
  n_cols = 60,
  iterations = 100000
)
cat(str)
```

Let's imagine we have this saved to an R script called `automaton.R`.

## The HTML

The html code for the site is very simple: it creates an empty div called "grid" for the javascript to modify, and uses the script contained in `webr-app.js` to do all the work:

``` html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Text Textures</title>
  </head>
  <body>
    <div id="grid">webR is starting, please wait...</div>
    <script src="./webr-app.js"></script>
  </body>
</html>
```

## The Javascript

Here's the source code for `webr-app.js`:

``` javascript
// import the webr module and then run the code
import('https://webr.r-wasm.org/latest/webr.mjs').then(async ({WebR}) => {

    // the HTML element showing the grid
    let grid = document.getElementById("grid");

    // wait for the webR session to start
    const webr = new WebR();
    await webr.init();

    // read the script as a string, and evaluate it in R
    let automaton = await fetch('automaton.R');
    await webr.evalR(await automaton.text());

    // initialise the state of the grid
    let str = await webr.evalR('automaton()')
    grid.innerHTML = (await str.toJs()).values;

    // function to update the state of the grid
    async function grid_update() {
        await webr.objs.globalEnv.bind('str', grid.innerHTML)
        let str = await webr.evalR('automaton(str)')
        grid.innerHTML = (await str.toJs()).values;
    }

    // repeatedly call the update function
    while (true) {
        await grid_update();
    }
});
```



<!--------------- appendices go here ----------------->



