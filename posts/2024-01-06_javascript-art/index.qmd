---
title: "javascript-art"
description: "This is a subtitle"
date: "2024-01-06"
--- 

<!--------------- my typical setup ----------------->

```{r}
#| label: setup
#| include: false
very_wide <- 500
wide <- 136
narrow <- 76
options(width = narrow)
cache_images <- TRUE
set.seed(1)
```

<!--------------- post begins here ----------------->

```{ojs}
//| column: body-outset
//| fig-align: center
//| fig-cap: one art
pic100 = pastiche(100)
```

```{ojs}
//| column: body-outset
//| fig-align: center
//| fig-cap: another art
pic101 = pastiche(101)
```

```{ojs}
seedrandom = require('seedrandom@3.0.5')
```


```{ojs}
function pastiche(seed) {

  const pars = {height: 600, width: 1000, nrow: 6, ncol: 10, iter: 100}
  
  // random number generator and canvas
  const rng = seedrandom(seed)
  let ctx = DOM.context2d(pars.width, pars.height)  
  
  // sample palette and set canvas background
  const palette = sampleArray(palettes, rng)
  ctx.fillStyle = sampleArray(palette, rng)
  ctx.fillRect(0, 0, pars.width, pars.height)

  // define the grid
  let grid = defineGrid(pars, palette, rng)

  // create the image
  for (let i = 0; i < pars.iter; i++) {
    grid.map(cell => {
      cell.draw(ctx)
      cell.update(rng)
    })
  }

  return ctx.canvas
}
```


```{ojs}
function defineGrid(pars, palette, rng) {
  const rowheight = pars.height / pars.nrow
  const colwidth = pars.width / pars.ncol
  const s = Math.min(rowheight, colwidth) * 2
  
  let grid = []
  let k = 0
  for (let c = 0; c < (pars.ncol - 1); c++) {
    for (let r = 0; r < (pars.nrow - 1); r++) {
      grid[k] = {
        id: k,
        col: c,
        row: r,
        size: s,
        x: colwidth * (c + 1),
        y: rowheight * (r + 1),
        xmax: pars.width,
        ymax: pars.height,
        xstep: colwidth,
        ystep: rowheight,
        start: Math.PI * 2 * rng.double(),
        stop: Math.PI * 2 * rng.double(),
        valid: true,
        shade: sampleArray(palette, rng),
        vertical: rng.double() < .5,
        exponent: .9,
        draw: function(ctx) { drawCell(this, ctx) },
        update: function(rng) { updateCell(this, rng) }
      }
      k++
    }
  }
  return grid
}
```

```{ojs}
function drawCell(cell, ctx) {
  
  const w = ctx.canvas.width
  const h = ctx.canvas.height
  
  function drawOne(x, y) {
    ctx.fillStyle = cell.shade
    ctx.strokeStyle = cell.shade
    ctx.lineWidth = 5
    ctx.beginPath()
    ctx.arc(x, y, cell.size, cell.start, cell.stop)
    ctx.fill()
    ctx.stroke()
    ctx.closePath();
  }
  
  // the "base" shape
  drawOne(cell.x, cell.y)
  
  // boundaries to consider for wrapping
  let xover  = (cell.x + cell.size) > h      
  let yover  = (cell.y + cell.size) > w
  let xunder = (cell.x - cell.size) < 0
  let yunder = (cell.y - cell.size) < 0
  
  // cases where we wrap around one boundary
  if (xover)  drawOne(cell.x - w, cell.y)
  if (yover)  drawOne(cell.x, cell.y - h)
  if (xunder) drawOne(w - cell.x, cell.y)
  if (yunder) drawOne(cell.x, h - cell.y)
  
  // cases where we wrap around both boundaries
  if (xover & yover)   drawOne(cell.x - w, cell.y - h)
  if (xover & yunder)  drawOne(cell.x - w, h - cell.y)
  if (xunder & yover)  drawOne(w - cell.x, cell.y - h)
  if (xunder & yunder) drawOne(w - cell.x, h - cell.y)
}
```    

```{ojs}
function updateCell(cell, rng) {
  if (cell.vertical) {
    cell.y = cell.y + cell.ystep * rng.double()
    if (cell.y > cell.ymax) cell.y = cell.y - cell.ymax
    if (cell.y < 0) cell.y = cell.ymax - cell.y
  } else {
    cell.x = cell.x + cell.xstep * rng.double()
    if (cell.x > cell.xmax) cell.x = cell.x - cell.xmax
    if (cell.x < 0) cell.x = cell.xmax - cell.x
  }
  cell.size = cell.size * cell.exponent
  cell.start = Math.PI * 2 * rng.double()
  cell.stop = Math.PI * 2 * rng.double()
}
```

```{ojs}
function sampleArray(items, rng) {
  return(items[Math.floor(rng.double()*items.length)]);
}
```

```{ojs}
palettes = [
  ["#de9151", "#f34213", "#2e2e3a", "#bc5d2e", "#bbb8b2"],
  ["#a63446", "#fbfef9", "#0c6291", "#000004", "#7e1946"],
  ["#ffffff", "#ffcad4", "#b0d0d3", "#c08497", "#f7af9d"],
  ["#aa8f66", "#ed9b40", "#ffeedb", "#61c9a8", "#ba3b46"],
  ["#241023", "#6b0504", "#a3320b", "#d5e68d", "#47a025"],
  ["#64113f", "#de4d86", "#f29ca3", "#f7cacd", "#84e6f8"],
  ["#660000", "#990033", "#5f021f", "#8c001a", "#ff9000"],
  ["#c9cba3", "#ffe1a8", "#e26d5c", "#723d46", "#472d30"],
  ["#0e7c7b", "#17bebb", "#d4f4dd", "#d62246", "#4b1d3f"],
  ["#0a0908", "#49111c", "#f2f4f3", "#a9927d", "#5e503f"],
  ["#020202", "#0d324d", "#7f5a83", "#a188a6", "#9da2ab"],
  ["#c2c1c2", "#42213d", "#683257", "#bd4089", "#f51aa4"],
  ["#820263", "#d90368", "#eadeda", "#2e294e", "#ffd400"],
  ["#f4e409", "#eeba0b", "#c36f09", "#a63c06", "#710000"],
  ["#d9d0de", "#bc8da0", "#a04668", "#ab4967", "#0c1713"],
  ["#012622", "#003b36", "#ece5f0", "#e98a15", "#59114d"],
  ["#3c1518", "#69140e", "#a44200", "#d58936", "#fffb46"],
  ["#6e0d25", "#ffffb3", "#dcab6b", "#774e24", "#6a381f"],
  ["#bcabae", "#0f0f0f", "#2d2e2e", "#716969", "#fbfbfb"],
  ["#2b4162", "#385f71", "#f5f0f6", "#d7b377", "#8f754f"]
]
```
