{
  "hash": "b6e6d2ba0099a8984a545753518ccba7",
  "result": {
    "markdown": "---\ntitle: \"Zero-copy data handover between R and Python, using Arrow and reticulate\"\ndescription: \"A neat trick\"\ndate: \"2022-08-28\"\ncategories: [Apache Arrow, R, Python]\nimage: \"img/cover.jpg\"\nengine: knitr\n---\n\n\n<!-- \ncover img: https://unsplash.com/photos/k39RGHmLoV8\nartist: Claudio Schwarz\nlicence: unsplash free-to-use \n-->\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!-- \nthe default python environment is this one:\n/home/danielle/.local/share/r-miniconda/envs/r-reticulate/bin/python\n--->\n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\nlibrary(reticulate)\n```\n:::\n\n\nThe {reticulate} package has an elaborate lookup mechanism that it uses to find a python environment. In this post and the next I want to make sure that I'm always using the *same* python environment regardless of whether my underlying quarto engine is knitr or jupyter. This is tricky because -- thanks to the nightmare that is python environment managment -- I've managed to accrue four different versions of python on my machine, and (don't ask me how) two separate copies of miniconda!\n\nRather than mess with paths, what I'm going to do in this post is be extremely specific. I'm going to make a point of *always* telling {reticulate} where to look in order to find python and miniconda. \n\nOkay, so the specific python environment I want to use is managed by miniconda, so I'm going to use the `use_miniconda()` command to tell {reticulate} to use it. To avoid all ambiguity I'm going to use the `condaenv` argument to explicitly specify the path to the python executable:\n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\nuse_miniconda(\n  condaenv = \"/home/danielle/miniconda3/bin/python\", \n  required = TRUE\n)\n```\n:::\n\n\nThe next step (if I hadn't done this already) would be to install pyarrow in the relevant python environment. The {arrow} package supplies a helper function called `install_pyarrow()` that you can use to do this, but it's just a convenience function that calls the relevant {reticulate} functions for you. For this post I'll do it using {reticulate}, and since my python environment is managed by miniconda I'll use `conda_install()`: \n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\nconda_install(\n  packages = \"pyarrow\", \n  envname = \"/home/danielle/miniconda3\", \n  conda = \"/home/danielle/miniconda3/bin/conda\"\n)\n```\n:::\n\n\nIn this code, `packages` is the name of the to-be-installed python module, `envname` is the path to the conda environment, and `conda` is the path to the conda executable. You probably don't need to be this explicit because {reticulate} generally handles these things nicely and manages its own copies of python and miniconda, but I am deliberately *not* using the reticulate-installed versions here!  \n\n\n<!-- <blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">And with an arrow table (or dataset) that handoff can be zero copy, zero serialization. We need to improve our docs around this but thereâ€™s an example in the tests that shows it off: <a href=\"https://t.co/ff5Am0fsCW\">https://t.co/ff5Am0fsCW</a> (some) docs: <a href=\"https://t.co/hg9G2NenIM\">https://t.co/hg9G2NenIM</a></p>&mdash; Jonathan Keane (@jonkeane) <a href=\"https://twitter.com/jonkeane/status/1560016227824721920?ref_src=twsrc%5Etfw\">August 17, 2022</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>  -->\n\n## Check my installation\n\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\nimport sys\nprint(sys.version)\nprint(sys.executable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.9.12 (main, Apr  5 2022, 07:05:27) \n[GCC 7.5.0]\n/home/danielle/miniconda3/bin/python\n```\n:::\n:::\n\n\nNext let's import {pyarrow} and check the version:\n\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\nimport pyarrow\npyarrow.__version__\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'8.0.0'\n```\n:::\n:::\n\n\nBecause life on linux is dark and full of terrors, this didn't actually work for me the first time I tried it and naturally I was filled with despair. Instead of the nice output above, I got an error saying:\n\n```\nlibstdc++.so.6: version `GLIBCXX_3.4.22' not found\n```\n\nAs usual, googling the error message led me to discover I needed to update the relevant library. It turned out to be an easy fix with this command: \n\n\n::: {.cell filename='[at the terminal]'}\n\n```{.bash .cell-code}\nsudo apt-get update\nsudo apt-get install libstdc++6\n```\n:::\n\n\n\n\n## Handover from R to Python\n\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\n# R\narr <- arrow::arrow_table(iris)\narr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTable\n150 rows x 5 columns\n$Sepal.Length <double>\n$Sepal.Width <double>\n$Petal.Length <double>\n$Petal.Width <double>\n$Species <dictionary<values=string, indices=int8>>\n\nSee $metadata for additional Schema metadata\n```\n:::\n\n```{.r .cell-code}\npy_arr <- reticulate::r_to_py(arr)\npy_arr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npyarrow.Table\nSepal.Length: double\nSepal.Width: double\nPetal.Length: double\nPetal.Width: double\nSpecies: dictionary<values=string, indices=int8, ordered=0>\n----\nSepal.Length: [[5.1,4.9,4.7,4.6,5,...,6.7,6.3,6.5,6.2,5.9]]\nSepal.Width: [[3.5,3,3.2,3.1,3.6,...,3,2.5,3,3.4,3]]\nPetal.Length: [[1.4,1.4,1.3,1.5,1.4,...,5.2,5,5.2,5.4,5.1]]\nPetal.Width: [[0.2,0.2,0.2,0.2,0.2,...,2.3,1.9,2,2.3,1.8]]\nSpecies: [  -- dictionary:\n[\"setosa\",\"versicolor\",\"virginica\"]  -- indices:\n[0,0,0,0,0,...,2,2,2,2,2]]\n```\n:::\n:::\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\n# python\nr.py_arr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npyarrow.Table\nSepal.Length: double\nSepal.Width: double\nPetal.Length: double\nPetal.Width: double\nSpecies: dictionary<values=string, indices=int8, ordered=0>\n----\nSepal.Length: [[5.1,4.9,4.7,4.6,5,...,6.7,6.3,6.5,6.2,5.9]]\nSepal.Width: [[3.5,3,3.2,3.1,3.6,...,3,2.5,3,3.4,3]]\nPetal.Length: [[1.4,1.4,1.3,1.5,1.4,...,5.2,5,5.2,5.4,5.1]]\nPetal.Width: [[0.2,0.2,0.2,0.2,0.2,...,2.3,1.9,2,2.3,1.8]]\nSpecies: [  -- dictionary:\n[\"setosa\",\"versicolor\",\"virginica\"]  -- indices:\n[0,0,0,0,0,...,2,2,2,2,2]]\n```\n:::\n:::\n\n\n## Handover from Python to R\n\n\n::: {.cell filename='[python code]'}\n\n```{.python .cell-code}\nboring = pyarrow.array([1,2,3])\nboring\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<pyarrow.lib.Int64Array object at 0x7f2fe18f3400>\n[\n  1,\n  2,\n  3\n]\n```\n:::\n:::\n\n::: {.cell filename='[R code]'}\n\n```{.r .cell-code}\nreticulate::py$boring\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nArray\n<int64>\n[\n  1,\n  2,\n  3\n]\n```\n:::\n:::\n\n\n\n<br><br>\n\n\n\n<!--------------- appendices go here ----------------->\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}