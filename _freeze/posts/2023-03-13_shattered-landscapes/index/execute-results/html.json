{
  "hash": "55c18233044611a8691dd9ae75d28974",
  "result": {
    "markdown": "---\ntitle: \"Shattered landscapes\"\nauthor:\n  - name: Danielle Navarro\n    url: https://djnavarro.net\n    affiliation: I'm on smoko\n    affiliation-url: https://www.youtube.com/watch?v=j58V2vC9EPc\n    orcid: 0000-0001-7648-6578\ndescription: \"Using ambient and rayshader to create weird, broken landcape images in R\"\ndate: \"2023-03-13\"\ncategories: [Art, R]\nimage: cover.png\n---\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n> Magic doesn't come from talent. It comes from pain. <br>\n> &nbsp; &nbsp; -- [Eliot Waugh](https://www.youtube.com/watch?v=WBeLX3O_mEU)^[Also Lev Grossman I guess, but honestly Hale Appleman's delivery is so good that I cannot possibly attribute the quote to anyone except Eliot.]\n\nIn the last few weeks I've been tinkering with a generative art system I ended up calling [*Broken Lands*](https://art.djnavarro.net/gallery/broken-lands/). It creates maps of bizarre and -- I expect -- impossible landscapes in R, using the [ambient](https://ambient.data-imaginist.com/) package to generate the topography, and [rayshader](https://www.rayshader.com/) to render shadows cast by a hypothetical light source. It creates images like these:\n\n:::{.column-screen-inset}\n:::{layout-ncol=3} \n\n![](https://djnavarro.net/series-broken-lands/3000/alien-floe_15_2406.png)\n\n![](https://djnavarro.net/series-broken-lands/3000/alien-floe_15_2416.png)\n\n![](https://djnavarro.net/series-broken-lands/3000/alien-floe_15_2496.png)\n\n:::\n:::\n\nTo my eye, at least, these images are both beautiful and tragic. I cannot help but interpret them as coastal landscapes in an alien geography of some kind, a land that has suffered some cataclysm like the [Doom of Valyria](https://awoiaf.westeros.org/index.php/Doom_of_Valyria) or the [Fall of Istar](https://dragonlancenexus.com/the-rise-and-demise-of-istar/). The contours feel too contorted to be the result of any terrestrial process, and -- again, by my interpretation -- there's a tension between the smoothness of the individual contours and the jagged, chaotic structure of the landscape overall. \n\nBut what would I know? I wrote the code that makes the system work, but I don't have a monopoly of interpretation of the images. [Death of the author](https://en.wikipedia.org/wiki/The_Death_of_the_Author) and all that. Barthes would call me the \"scriptor\" rather than the author, I suppose, which honestly feels about right for generative art. So yeah. The pieces are what they are, quite separate from the artist and from the process by which the system was constructed.\n\nThat said, if you're familiar with the R ecosystem you can probably take an educated guess about the tools I used to make these pieces. The spatial noise patterns that form the basis of these pieces are created using the [ambient](https://ambient.data-imaginist.com/) package. The shadows and three-dimensional look are provided by  [rayshader](https://www.rayshader.com/). I wrote about both of these packages in my workshop on [generative art in R](https://art-from-code.netlify.app/) workshop (specifically: [ambient art](https://art-from-code.netlify.app/day-1/session-2/), [rayshader  art](https://art-from-code.netlify.app/day-1/session-4/)), and those tutorials are probably the place to begin if you've never used either of these packages for generative art before.\n\nLet's set a random seed that we'll use for all the random components throughout the post:^[Why 14? No reason. I got to the end of the post after tinkering with lots of things and with lots of seeds, was happy with what I'd coded, and then asked my daughter to give me a random number that I could use for this post, because I didn't want it to seem like I'd engaged in \"seed hacking\" to make it look pretty.] ^[There's an obvious parallel between seed hacking in generative art and p-hacking in statistics, but I refuse to go down that path. I've had so many tediously overconfident men in oPeN sCIenCe lecture me at length on p-hacking, and berating me for my quEStionAbLe reSeArcH PRaCtiCe when I've suggested that in real world inference there are cases where statistics should not adhere strictly to the rules laid down by Jerzy Neyman that... well, quite frankly, at this point in my life I loathe the whole concept of $p$ and everyone who talks about it.] ^[Yes, *men*. Without fail, the people berating me for daring to know something about the limits of classical null hypothesis tests have been men. I'll let you know if that changes, but in my life experience to date, mansplaining seems to be an extremely gendered phenomenon.] \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseed <- 14\n```\n:::\n\n\n\n<br>\n\n## Starting simple\n\nI'll start by building a simple system that doesn't go very far beyond what I covered in the *Art From Code* workshop. It's built using three functions. There's a `new_grid()` function used to define a grid of x and y coordinates, a `generate_simplex()` function used to create spatial noise patterns on such a grid, and a `render()` function used to create an image. First, the `new_grid()` function:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_grid <- function(n = 1000) {\n  ambient::long_grid(\n    x = seq(0, 1, length.out = n),\n    y = seq(0, 1, length.out = n)\n  )\n}\n\nnew_grid()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000,000 × 2\n       x       y\n   <dbl>   <dbl>\n 1     0 0      \n 2     0 0.00100\n 3     0 0.00200\n 4     0 0.00300\n 5     0 0.00400\n 6     0 0.00501\n 7     0 0.00601\n 8     0 0.00701\n 9     0 0.00801\n10     0 0.00901\n# … with 999,990 more rows\n```\n:::\n:::\n\n\nThe output appears to be a tibble that contains x and y coordinates.^[It's actually a slightly different kind of object called a \"long grid\" but for now I'll treat it like a tibble] This defines the spatial locations that we'll use to create the image, but we'll need to assign colours to each of those locations. \n\n<br>\n\n### Painting a canvas with spatial noise\n\nIn order to do this, we'll write a function called `generate_simplex()` that generates interesting patterns of spatial noise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_simplex <- function(x, y, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  ambient::fracture(\n    noise = ambient::gen_simplex,\n    fractal = ambient::billow,\n    octaves = 10,\n    freq_init = .02,\n    frequency = ~ . * 2,\n    gain_init = 1,\n    gain = ~ . * .8,\n    x = x,\n    y = y\n  )\n}\n```\n:::\n\n\nThe particular choices I've made here came about from trial and error. I played around with a lot of different settings when creating generative art in this style, and these were things I liked. I'm not going to dive into the details here: you can find out more by reading the [tutorial on spatial noise art]([ambient art](https://art-from-code.netlify.app/day-1/session-2/)) I linked to earlier. For the current post, all I want to highlight is that we can use this function to add a new column to the `canvas` that defines our artwork:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanvas <- new_grid() |> \n  dplyr::mutate(paint = generate_simplex(x, y, seed = seed))\n\ncanvas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000,000 × 3\n       x       y paint\n   <dbl>   <dbl> <dbl>\n 1     0 0       -3.96\n 2     0 0.00100 -3.95\n 3     0 0.00200 -3.95\n 4     0 0.00300 -3.94\n 5     0 0.00400 -3.93\n 6     0 0.00501 -3.92\n 7     0 0.00601 -3.91\n 8     0 0.00701 -3.91\n 9     0 0.00801 -3.90\n10     0 0.00901 -3.89\n# … with 999,990 more rows\n```\n:::\n:::\n\n\nThis `canvas` object is structured like a lookup table: it's a data frame with columns specifying x and y coordinates, and it contains a third column that specifies the colour of \"paint\" that needs to be applied at each coordinate. However, it's a very structured data frame because the x and y values form a grid. This makes straightforward to flip from this format to a \"bitmap\" matrix format:^[Okay that's not quite correct. The `as.array()` method works here because we created this object by calling `ambient::long_grid()` rather than `tidyr::expand_grid()` or the `expand.grid()` function in base R. When you call `expand_grid()` all you're doing is creating a regular data frame (or tibble), and you can redefine the x and y values however you like. With a long grid object, however, you're creating a somewhat different data structure that is *required* to form a grid. You can't modify the x and y values the same way you would for a tibble, because those values are part of the underlying data structure. That seems like an odd restriction the first time you encounter it, but the fact that the grid itself is immutable is what makes it trivially easy to call `as.array()` in this context.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbitmap <- canvas |> as.array(value = paint)\nbitmap[1:6, 1:6]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      x\ny           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]\n  [1,] -3.963129 -3.931507 -3.899957 -3.868550 -3.837357 -3.806447\n  [2,] -3.954987 -3.932781 -3.901242 -3.869845 -3.838662 -3.807762\n  [3,] -3.946846 -3.924674 -3.902573 -3.871211 -3.840061 -3.809194\n  [4,] -3.938708 -3.916594 -3.894550 -3.872644 -3.841552 -3.810740\n  [5,] -3.930575 -3.908541 -3.886577 -3.864752 -3.843132 -3.812398\n  [6,] -3.922448 -3.900516 -3.878655 -3.856932 -3.835414 -3.814166\n```\n:::\n:::\n\n\nA grid of numbers isn't very pretty to look at, but we will need to create this matrix representation before passing the data to rayshader later. But I'm getting ahead of myself. For now, we can use the `image()` function to render an image from matrix-formatted data:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell hash='index_cache/html/simple-render_3eab0a7eeb32bc70f337c05d8f82896f'}\n\n```{.r .cell-code}\ncanvas |> \n  as.array(value = paint) |>\n  image(axes = FALSE, asp = 1, useRaster = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/simple-render-1.png){width=576}\n:::\n:::\n\n\nWe're a long way from our goal, but at least we now have an output that looks like art rather than a matrix of numbers. It's a start!\n\n<br>\n\n### Casting shadows across the landscape\n\nThe next step in the process is to define a `render()` function that will take an \"elevation\" matrix as input, but instead of drawing a \"heat map\" like `image()` does, it renders it as a three-dimensional topographic map with shadows cast by a hypothetical light source. This is surprisingly easy to do using rayshader. Here's the function I'll use in this post:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrender <- function(mat, shades = NULL, zscale = .005) {\n  if(is.null(shades)) {\n    n <- length(unique(mat))\n    shades <- hcl.colors(n, \"YlOrRd\", rev = TRUE)\n  }\n  rayshader::height_shade(\n    heightmap = mat,\n    texture = shades\n  ) |>\n    rayshader::add_shadow(\n      shadowmap = rayshader::ray_shade(\n        heightmap = mat,\n        sunaltitude = 50,\n        sunangle = 80,\n        multicore = TRUE,\n        zscale = zscale\n      ),\n      max_darken = .2\n    ) |>\n    rayshader::plot_map()\n}\n```\n:::\n\n\nI'm not going to go into the specifics: you can find out more by reading the [tutorial on rayshader art]([ambient art](https://art-from-code.netlify.app/day-1/session-4/)) I linked to earlier. For this post, I'm simply going to show you what it does. Taking the `canvas` data as input, we first use `as.array()` to switch from a \"data frame style\" representation to a \"matrix style\" representation, and then pass the matrix to `render()`:\n\n\n::: {.cell hash='index_cache/html/render-landscape_59c4a810d191eb5a7228c812793b479f'}\n\n```{.r .cell-code}\ncanvas |>\n  as.array(value = paint) |>\n  render()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/render-landscape-1.png){width=672}\n:::\n:::\n\n\nAgain, still a long way from our desired goal, but we are making progress. Thanks to rayshader, we have output that looks like a shaded topographic map.\n\n<br>\n\n### Making islands from the landscape\n\n<!--\n> I cut my bangs with some rusty kitchen scissors <br>\nI screamed his name 'til the neighbors called the cops <br>\nI numbed the pain at the expense of my liver <br>\nDon't know what I did next, all I know I couldn't stop <br>\n&nbsp; &nbsp; -- Miranda Lambert\n-->\n\nAt this point we have the ability to generate landscapes, but the images just look like a bunch of hills. They don't have the \"coastal\" feeling that the original images did. We can create islands by setting a \"sea level\". You can do this in a sophisticated way in rayshader using `detect_water()` and `add_water()`, but that's overkill for our purposes. All we really want to do is imagine setting a sea level such that about half the image is \"water\" and half the image is \"land\". To do that we just calculate the median value in the original data: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsea_level <- median(canvas$paint)\n```\n:::\n\n\nFrom there it's an exercise in using dplyr. Using `mutate()` we create a new \"islands\" column whose value is equal to the original value or the sea level, whichever is higher:\n\n\n::: {.cell hash='index_cache/html/render-islands_89c99343fd7783865ca6e6cfde8463a6'}\n\n```{.r .cell-code}\ncanvas |> \n  dplyr::mutate(\n    islands = dplyr::if_else(\n      condition = paint < sea_level,\n      true = sea_level, \n      false = paint\n    )\n  ) |>\n  as.array(value = islands) |>\n  render()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/render-islands-1.png){width=672}\n:::\n:::\n\n\nEt voilà! We have a generative art system that creates fictitious topographic maps of coastal islands. It's still not quite the same thing as the original, but it's kind of a nice system in itself. If you want to play with it, the complete source code for generating this image is included in the [islands.R](islands.R) script accompanying this post.\n\n<br>\n\n### Tweaking the spatial noise generator\n\nIf you do end up playing around, a really useful way to create variations on this system is to modify the function that generates the spatial noise patterns. For example, this `generate_fancy_noise()` function is awfully similar to the noise generator I used in the *Broken Lands* series:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_fancy_noise <- function(x, y, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  z <- ambient::fracture(\n    noise = ambient::gen_worley,\n    fractal = ambient::billow,\n    octaves = 8,\n    freq_init = .1,\n    frequency = ~ . * 2,\n    gain_init = 3,\n    gain = ~ . * .5,\n    value = \"distance2\",\n    x = x,\n    y = y\n  )\n  ambient::fracture(\n    noise = ambient::gen_simplex,\n    fractal = ambient::billow,\n    octaves = 10,\n    freq_init = .02,\n    frequency = ~ . * 2,\n    gain_init = 1,\n    gain = ~ . * .8,\n    x = x + z,\n    y = y + z\n  )\n}\n```\n:::\n\n\nHere it is in action:\n\n\n::: {.cell hash='index_cache/html/island-fancy-noise_53f5ddc84ded78d671abebedeed2a975'}\n\n```{.r .cell-code}\nnew_grid() |>\n  dplyr::mutate(\n    height = generate_fancy_noise(x, y, seed = seed),\n    islands = dplyr::if_else(\n      condition = height < median(height),\n      true = median(height),\n      false = height\n    )\n  ) |>\n  as.array(value = islands) |>\n  render(zscale = .01)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/island-fancy-noise-1.png){width=672}\n:::\n:::\n\n\nVery pretty. I suspect that had I isolated this particular noise generator earlier in the artistic process -- rather than figuring out in hindsight that this was what I'd been using all along -- I might have stopped here, and not bothered with any of the other tricks that I actually used.^[Easter egg for the three people who know the reference: I rather suspect that what I've done in this section is create the artistic version of the \"linear ballistic accumulator\" model of human choice behaviour, where my original system was a full fledged diffusion model. Happily for all concerned, neither Scott nor Roger are going to read this post.] But of course this is a post-mortem deconstruction,^[Fortunately for me, this is an art post and not a reGIStEreD RepORt, so I'm allowed to talk freely about this deconstruction. In a former life I'd have spent about three months arguing with petty reviewers about the distinction between deconstruction and HARKing, and frankly life is too short for that bollocks.] not a description of the bizarrely tangled artistic process I actually followed, so there are more layers to come...\n\n<br>\n\n## Queering geography\n\nThe final image in the last section captures something about the overall structure of the *Broken Lands* images, but it feels wrong in the particulars. It's too smooth, too fluid, too... natural. It doesn't have the same feel as the originals. I don't have the same feeling of alienness that the original pieces have. Where does that not-quite-real feeling come from?  \n\nThe answer to this involves every generative artists favourite trick: curl fields. If you've read the tutorial articles I linked to earlier, you've encountered these before so I won't repeat myself by explaining yet again what a curl field is. What I'll do instead is write a `generate_curl()` function that takes the original grid of coordinates (in the \"base\" space) and transforms them to a new set of points (in an \"embedding\" space) using a curl transformation:^[Fine. Yes, if you look closely at the code you can see I'm doing more than simply applying a curl field. But please... allow me some latitude here. This is a blog post not a dissertation.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_curl <- function(x, y, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  ambient::curl_noise(\n    generator = ambient::fracture,\n    noise = ambient::gen_simplex,\n    fractal = ambient::fbm,\n    octaves = 3,\n    frequency = ~ . * 2,\n    freq_init = .3,\n    gain_init = 1,\n    gain = ~ . * .5,\n    x = x,\n    y = y\n  )\n}\n```\n:::\n\n\nHere's what happens when we apply this function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- new_grid()\ncoords <- generate_curl(grid$x, grid$y, seed = seed)\nhead(coords)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             x        y\n1 1.417494e-07 2.625000\n2 4.275159e-05 2.624981\n3 1.705772e-04 2.624924\n4 3.836068e-04 2.624829\n5 6.818209e-04 2.624697\n6 1.065192e-03 2.624526\n```\n:::\n:::\n\n\nThe code here is slightly unpleasant, yes, but I'll do it in a slightly cleaner way in a moment. What matters right now is the fact that the `coords` data frame is a transformed version of the `grid` data. The original (x,y) coordinates in the base space have been transformed to some (x,y) coordinates in some new space. \n\nA slightly cleaner way of doing this -- keeping both the original coordinates and the transformed values -- would be as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanvas <- grid |>\n  dplyr::mutate(\n    curl_x = coords$x,\n    curl_y = coords$y\n  )\n\ncanvas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000,000 × 4\n       x       y      curl_x curl_y\n   <dbl>   <dbl>       <dbl>  <dbl>\n 1     0 0       0.000000142   2.62\n 2     0 0.00100 0.0000428     2.62\n 3     0 0.00200 0.000171      2.62\n 4     0 0.00300 0.000384      2.62\n 5     0 0.00400 0.000682      2.62\n 6     0 0.00501 0.00107       2.62\n 7     0 0.00601 0.00153       2.62\n 8     0 0.00701 0.00209       2.62\n 9     0 0.00801 0.00273       2.62\n10     0 0.00901 0.00345       2.62\n# … with 999,990 more rows\n```\n:::\n:::\n\n\nOkay that's nice, but what exactly are these \"curl transformed\" values? What do they look like? Fair question. Here's a plot showing what has happened to our nice rectangular grid after the transformation...\n\n\n\n::: {.cell hash='index_cache/html/plot-curl-transform_024c86bb8595fbe107b5f6ae51d9ba2f'}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-curl-transform-1.png){width=672}\n:::\n:::\n\n\nThis image has an evocative feel, right? Like I've taken a regular square sheet of fabric and folded or transformed it in some strange way to create an \"embedded\" manifold? Well, yeah. That's precisely what I've done.\n\nOur noise operations will be specified on this transformed/embedded manifold, but -- to reveal the ending slightly too soon -- the final image will be defined on the base space. The code below shows how to apply the noise operations in the embedding space:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanvas <- canvas |>\n  dplyr::mutate(\n    height = generate_fancy_noise(curl_x, curl_y, seed = seed),\n    islands = dplyr::if_else(\n      condition = height < median(height),\n      true = median(height),\n      false = height\n    )\n  )\n\ncanvas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000,000 × 6\n       x       y      curl_x curl_y height islands\n   <dbl>   <dbl>       <dbl>  <dbl>  <dbl>   <dbl>\n 1     0 0       0.000000142   2.62 -0.676  -0.676\n 2     0 0.00100 0.0000428     2.62 -0.675  -0.675\n 3     0 0.00200 0.000171      2.62 -0.674  -0.674\n 4     0 0.00300 0.000384      2.62 -0.672  -0.672\n 5     0 0.00400 0.000682      2.62 -0.670  -0.670\n 6     0 0.00501 0.00107       2.62 -0.667  -0.667\n 7     0 0.00601 0.00153       2.62 -0.664  -0.664\n 8     0 0.00701 0.00209       2.62 -0.662  -0.662\n 9     0 0.00801 0.00273       2.62 -0.660  -0.660\n10     0 0.00901 0.00345       2.62 -0.658  -0.658\n# … with 999,990 more rows\n```\n:::\n:::\n\n\nJust to give you a sense of what that looks like in the embedding space, here's what happens when we redraw the \"manifold\" plot from above, with each point coloured using the value of the \"islands\" variable:\n\n\n::: {.cell hash='index_cache/html/demo-worley-distance_ad5074cdd8c189365ccd09e3cb6846a3'}\n::: {.cell-output-display}\n![](index_files/figure-html/demo-worley-distance-1.png){width=672}\n:::\n:::\n\n\nYou can sort of see what's going on here. We have a spatial noise pattern that generated the topography that I showed in the last section, but it's defined on the *embedding* space. Our *base* space is like a rectangular fabric that has been laid and folded over and over onto this embedding space, and then we've spray painted this pattern onto the fabric.^[Presumably using some magic spray paint that coats every layer of the folded fabric, not just the topmost layer!] ^[Okay yes the metaphor is a bit strained, but it's the best I can think of when what I'm actually doing is constructing a surjective mapping from the base space to the embedding space, adding noise to the mapped values, and then using \"magic\" to pull back to the base space because I'm a good girl who doesn't throw away the original values when she performs a many-to-one trick.] ^[Yes I'm aware that the \"many to one\" jokes write themselves at this point but as I mentioned previously I am a good girl so I shan't continue this line of thought.] When we unfold the spray painted fabric and lay it flat again, this is what we get:\n\n\n::: {.cell hash='index_cache/html/unfolded-fabric_2e7f26189e4931538cd79b6853c25fe4'}\n\n```{.r .cell-code}\ncanvas |> \n  as.array(value = islands) |>\n  image(axes = FALSE, asp = 1, useRaster = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unfolded-fabric-1.png){width=576}\n:::\n:::\n\n\nIt's a bit like tie-dyeing I guess? That's what it feels like to me. I'm taking something regular, scrunching it up in a strange way, and then applying the colours to the scrunched up object before unfolding it. \n\nIn any case, we can use our `render()` function to add shadows with rayshader:\n\n\n::: {.cell hash='index_cache/html/plot-worley-distance_12c95c9c90abd9891eab921e41c0ca53'}\n\n```{.r .cell-code}\ncanvas |> \n  as.array(value = islands) |>\n  render(zscale = .05)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-worley-distance-1.png){width=672}\n:::\n:::\n\n\nOkay now *that* feels like an alien geography to me! It still doesn't look at all like our final images, but it has the right feel to it. Yes, it's still a geography of sorts, but it feels stretched and twisted in an unnatural way. It feels... well, it feels *painful*. Nothing like this can occur naturally without the action of some catastrophic process. That's what it feels like to me. The \"brokenness\" of the original images is created by this transformation: natural-ish patterns imposed on a twisted space create bizarre and alien patterns when those contortions are unfolded. It feels weird... it feels strange... it feels queer.^[There is an obvious metaphor for the queer experience of living in a world defined by cisheteronormativity here, but I'll let you flesh out the rest of the mapping on your own. You're a clever person, you know how to read between the lines, right?]\n\n## Artistic trickery\n\nThe last image in the previous section doesn't look all that much like the *Broken Lands* pieces, but -- perhaps surprisingly -- we're weirdly close to creating something that really does look like those pieces. There are no deep insights left to explore. From here on out, it's really just a matter of applying a few artistic tricks. To be precise, there are three little tricks left to document. \n\n<br>\n\n### Be discre[et|te]\n\nThe first trick is discretisation. So far we've been creating images in which the \"elevation\" of the landscapes vary smoothly. The *Broken Lands* images don't do that. Instead, there is a distinct feeling that the lands are terraced. In the original pieces there's that same unnatural terracing that that you see in [open cut mining](https://en.wikipedia.org/wiki/Open-pit_mining).^[I grew up in a small mining town, four hours drive from the nearest city (sort of: technically it was the town founded around the refinery, and the mines were about an hour away). It was traumatic, and there are not enough drugs in the world to make me elaborate.] Creating that look in this system is not difficult. First, I'll define a `discretise()` function that takes a continuously-varying vector as input, cuts it into `n` distinct levels that vary in value between 0 and 1, and returns the discretised values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscretise <- function(x, n) {\n  round(ambient::normalise(x) * n) / n\n}\n```\n:::\n\n\nHere's an example in which 100 normally distributed numbers are sliced into 5 levels:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscretise(rnorm(100), 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 0.6 0.8 0.2 0.4 0.6 0.4 0.6 0.4 0.8 0.6 0.4 0.2 0.2 0.4 0.6 0.6 0.6\n [18] 0.4 0.6 0.4 0.8 0.4 0.4 0.6 0.6 0.4 0.2 0.0 0.4 0.6 0.6 0.4 0.0 0.8\n [35] 0.2 0.2 0.4 0.6 0.4 0.4 0.8 0.4 0.4 0.4 0.4 0.2 0.4 0.2 0.6 0.4 0.8\n [52] 0.6 0.6 0.4 0.6 0.6 0.6 0.8 0.4 0.6 0.4 0.4 0.4 0.8 0.6 0.4 0.4 0.8\n [69] 0.4 0.2 0.4 0.2 0.6 0.2 0.2 0.8 0.4 0.4 0.6 0.4 0.6 0.4 0.8 0.6 0.4\n [86] 0.0 0.6 0.4 1.0 0.4 0.6 0.4 0.8 0.0 0.8 0.4 0.8 0.8 0.2 0.6\n```\n:::\n:::\n\n\nTo create a discretised version of our alien landscapes, all we have to do is liberally pepper our original code with a few calls to `discretise()`. Here's an example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- new_grid() \ncoords <- generate_curl(grid$x, grid$y, seed = seed)\n\ncanvas <- grid |> \n  dplyr::mutate(\n    curl_x = coords$x |> discretise(50), \n    curl_y = coords$y |> discretise(50),\n    height = generate_fancy_noise(curl_x, curl_y, seed = seed) |> \n      discretise(50),\n    islands = dplyr::if_else(\n      condition = height < median(height),\n      true = median(height),\n      false = height\n    )\n) \n\ncanvas\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,000,000 × 6\n       x       y curl_x curl_y height islands\n   <dbl>   <dbl>  <dbl>  <dbl>  <dbl>   <dbl>\n 1     0 0         0.32      1   0.72    0.72\n 2     0 0.00100   0.32      1   0.72    0.72\n 3     0 0.00200   0.32      1   0.72    0.72\n 4     0 0.00300   0.32      1   0.72    0.72\n 5     0 0.00400   0.32      1   0.72    0.72\n 6     0 0.00501   0.32      1   0.72    0.72\n 7     0 0.00601   0.32      1   0.72    0.72\n 8     0 0.00701   0.32      1   0.72    0.72\n 9     0 0.00801   0.32      1   0.72    0.72\n10     0 0.00901   0.32      1   0.72    0.72\n# … with 999,990 more rows\n```\n:::\n:::\n\n\nIf we plot this as a heatmap, the discrete levels are immediately obvious:\n\n\n::: {.cell hash='index_cache/html/unfolded-fabric-discrete_b8a32407e08fed0238b23d30819ea920'}\n\n```{.r .cell-code}\ncanvas |> \n  as.array(value = islands) |>\n  image(axes = FALSE, asp = 1, useRaster = TRUE) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unfolded-fabric-discrete-1.png){width=576}\n:::\n:::\n\n\nThis terracing has the effect of levelling out some of the more bizarre features of the alien landscape we plotted earlier. Here's what we get when we pass this terraced landscape to our `render()` function:\n\n\n::: {.cell hash='index_cache/html/rayshaded_6ae7540888474db59e0519b96d8fdf8b'}\n\n```{.r .cell-code}\ncanvas |> \n  as.array(value = islands) |>\n  render(zscale = .01) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rayshaded-1.png){width=672}\n:::\n:::\n\n\nAh, yes. Now we have something that feels closer to the *Broken Lands* pieces. The twists and contortions of the alien landscape are preserved, but they have now been forced onto a flatter, controlled geometry. The chaos of the alien land has been tamed. This is a domesticated variant. Safe for children and capitalists alike.\n\n<br>\n\n### Be smooth\n\nAt some level I appreciate the stark feel of the previous piece, but even I am not enough of a masochist^[Which, let's be frank, is saying quite a lot.] to truly enjoy the brutality of what I just did. All those intricate alien swirls have been flattened and erased so crudely that we are left with something a little too minimal for my tastes. \n\nAnd so to the second artistic sleight-of-hand: some of the starkness of the last piece can be ameliorated if we apply noise processes in both the embedding space (i.e., noise is applied to `curl_x` and `curl_y`) and in the base space (i.e., to `x` and `y`). The code for that might look a little like this:\n\n\n::: {.cell hash='index_cache/html/mixed-method_038429f2e450bbe1fc914f53688a602f'}\n\n```{.r .cell-code}\ngrid <- new_grid() \ncoords <- generate_curl(grid$x, grid$y, seed = seed)\n\ncanvas <- grid |> \n  dplyr::mutate(\n    curl_x = coords$x |> discretise(50), \n    curl_y = coords$y |> discretise(50),\n    noise_curl = generate_fancy_noise(curl_x, curl_y, seed = seed),\n    noise_base = generate_simplex(x, y, seed = seed),\n    height = (noise_curl + noise_base) |> discretise(50),\n    islands = dplyr::if_else(\n      condition = height < median(height),\n      true = median(height),\n      false = height\n    )\n) \n\ncanvas |> \n  as.array(value = islands) |>\n  render(zscale = .01) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/mixed-method-1.png){width=672}\n:::\n:::\n\n\nThere is no principle to this. No deep underlying logic. It is simply an attempt to paper over the cracks, to smooth out some of the raw, sharp edges that were left over when we discretised in the first step. \n\nThere is probably a life metaphor here, but I choose not to look too closely.\n\n<br>\n\n### Be chaotic\n\nThe final layer of trickery involves the colour palette. Throughout this post I've used the default \"yellow and red\" palette that `image()` uses to create heat map images, but the `render()` function I wrote at the beginning lets you choose your own colour scheme. For instance, let's say I want the land to vary smoothly along a \"teal and green\" colour palette, while having the water stay white (or thereabouts). It's surprisingly straightforward to do this, by passing a hand crafted vector of colours to `render()`:\n\n\n::: {.cell hash='index_cache/html/manual-colour_98e82ce263e6d6c08a8c44be9b7ceb1c'}\n\n```{.r .cell-code}\nshades <- hcl.colors(50, \"TealGrn\")\nshades[1] <- \"#ffffff\"\n\ncanvas |> \n  as.array(value = islands) |>\n  render(shades = shades) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/manual-colour-1.png){width=672}\n:::\n:::\n\n\nThis is so very, very close to the style of imagery in the original *Broken Lands* series. The only thing missing is a slight feeling of chaos to the colours. If you scroll back up to the top of the post you'll notice that the original images don't quite adhere to the smoothly-varying-shades feel of a proper topographic map. The reason for this is that I shuffled the colour palette, so each \"level\" in the discrete map has a randomly sampled colour from the palette. Here's some code that does precisely that:\n\n\n::: {.cell hash='index_cache/html/manual-colour-shuffled_ab41e7b2a8c5325c9f9ef9f713abc54d'}\n\n```{.r .cell-code}\ngenerate_shades <- function(palette = \"TealGrn\", n = 50, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  shades <- hcl.colors(n, palette)\n  shades <- sample(shades)\n  shades[1] <- \"#ffffff\"\n  shades  \n}\n\ncanvas |> \n  as.array(value = islands) |>\n  render(shades = generate_shades(seed = seed)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/manual-colour-shuffled-1.png){width=672}\n:::\n:::\n\n\n... and there it is. This version of the system isn't precisely equivalent to the original, but it mirrors it in every respect that matters to me. The magic is all laid bare. There are no artistic secrets left in this system. Everything you need to know about these images is committed to text. Documented. Described. Codified. \n\nI love the originals no less now that the magic is revealed. There is no art in secrecy.\n\n<br>\n\n## Goodnight, sweet dreams\n\n> One day we're gonna wake up laughing <br>\nPut on your dancing shoes <br>\nYou won't believe the tales I tell <br>\nThat time, Danielle, ain't mine to choose <br>\nDanielle, Danielle, Danielle <br>\n&nbsp; &nbsp; -- [Tex Perkins](https://youtu.be/RClo-JU-8P4?t=79) (and others, but whatever...)^[A note for foreigners: if you are an Australian male-attracted person of a certain age, you immediately understand. It doesn't matter if you're a bisexual, a straight woman, or a gay man. It doesn't matter if you got hooked by Beasts of Bourbon, or by Cruel Sea, or by the solo acts. There's nothing specific to it. There are no invariants to uncover except Tex Perkins.]\n\nMuch like the *Broken Lands* system itself,^[The very earliest version of the system appeared as a throwaway piece in the [quarantine moods](https://art.djnavarro.net/gallery/quarantine/) series, then became frozen in the [ice floes](https://art.djnavarro.net/gallery/ice-floes/) system, re-emerged as the [fractured terrain](https://art-from-code.netlify.app/day-1/session-4/#fractured-terrain) section in the *Art From Code* workshop, and then eventually became its own [thing](https://art.djnavarro.net/gallery/broken-lands/).] this post has a peculiar genesis. If you read the [strange year](https://blog.djnavarro.net/posts/2022-12-26_strange-year/) post I wrote a few months ago, you'd be unsurprised to hear that I am attempting to [square a few circles](https://en.wikipedia.org/wiki/Squaring_the_circle) right now. Something broke -- rather badly -- and I'm trying to work out how to put the pieces together even knowing that the shattered parts can't go back together in the shape they were before. Aspects to my life that were once central to my sense of self are scattered, and there are little slivers of glass laid everywhere -- when I attempt to pick up one of the pieces from the floor I get cut deeply by those tiny transparent needles. \n\nThis post is one of those attempts. One of the pieces I need to pick up is my writing. The little cataclysm of 2022 broke my writing. I didn't become a bad writer, or at least I don't think I did. Rather, I lost my sense of ownership over my writing, and it's been some work trying to regain that. \n\nAnd so to the point...\n\nI wrote this post because I loved creating the artwork, and it's written the way it is written because it makes me happy to write again. That's it. It's something I wrote because I want to own my words again. There's no \"take home message\". There's no \"call to action\". You can love it, or hate it, or ignore it. That's okay: I didn't write it for you.\n\nI wrote it for me.\n\n\n\n<!--------------- appendices go here ----------------->\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}