{
  "hash": "ef6f2001018f41f3dbb87e7796ba93f8",
  "result": {
    "markdown": "---\ntitle: Passing Arrow data between Python and R with rpy2\ndescription: 'Part two of the data-sharing post. An approach to sharing Arrow Tables between R and Python, using the rpy2 Python module in place of the reticulate R package. The same goal is achieved, using a slightly more Pythonic toolkit'\ndate: '2022-09-02'\ncategories:\n  - Apache Arrow\n  - R\n  - Python\nimage: img/cover.jpg\n---\n\n<!-- \ncover img: https://unsplash.com/photos/C4sxVxcXEQg\nartist: Reuben Juarez\nlicence: unsplash free-to-use \n-->\n\n<!-- \n# bash commands to build this post\nconda activate continuation\ncd ~/GitHub/sites/quarto-blog/posts/2022-09-02_arrow-and-rpy2\nquarto render index.qmd --execute-daemon-restart\n-->\n\n> Me: I'm tired I don't wanna write my blog post you do it <br>\n> 12yo: no <br>\n> Me: pleeeeeeease? you just have to show people how to hand an Arrow Table from Python to R with rpy2 it's just a smol post <br>\n> 12yo: I don't know what that is <br>\n> 9yo: also that's child labour <br>\n> &nbsp; &nbsp; -- my children, showing good personal boundaries\n\nIn the [last post on this blog](/posts/2022-09-01_reticulated-arrow/) I showed how Apache Arrow makes it possible to hand over data sets from R to Python (and vice versa) without making wasteful copies of the data. \n\nThe solution I outlined there was to use the [reticulate](https://rstudio.github.io/reticulate/) package to conduct the handover, and rely on Arrow tools both sides to manage the data. In one sense it's a perfectly good solution to the problem... but it's a solution tailor made for R users who need access to Python. When viewed from the perspective of a Python user who needs access to R, it's a little awkward to have an R package (reticulate) governing the handover.^[Relatedly, if you're a Python user blogging in quarto, you are very unlikely to be using the [knitr engine](https://quarto.org/docs/reference/cells/cells-knitr.html) to execute code like I did in the last blog post. Instead you're almost certainly using the [jupyter engine](https://quarto.org/docs/reference/cells/cells-jupyter.html). With that in mind, and with the goal of making this post a little more Pythonic, I'm using Jupyter this time.] Perhaps we can find a more Pythonic way to approach this?\n\nA solution to our problem is provided by the [rpy2 module](https://rpy2.github.io/) that provides an interface to R from Python, and the [rpy2-arrow extension module](https://rpy2.github.io/rpy2-arrow/version/main/html/index.html) that allows it to support Arrow objects. Let's take a look, shall we?\n\n## Setting up the Python environment\n\nFor the purposes of this post I'll create a fresh conda environment that I'll call \"continuation\", both because this post is a continuation of the previous one and because the data set I'll use later is called [To Be Continued](https://cdhrdatasys.anu.edu.au/tobecontinued/). I was able install most packages I need through conda-forge, but for rpy2 and rpy2-arrow I was only able to do so from pypi so I had to use pip for that. So the code for setting up my Python environment was as follows:\n\n``` bash\nconda create -n continuation\nconda install -n continuation pip pyarrow pandas jupyter\nconda activate continuation\npip install rpy2 rpy2-arrow\n```\n\n\n## Introducing rpy2\n\nThe purpose of the rpy2 library is to allow users to call R from Python, typically with the goal of allowing access to statistical packages distributed through CRAN. I'm currently using version 3.5.4, and while this blog post won't even come close to documenting the full power of the library, the [rpy2 documentation](https://rpy2.github.io/doc/v3.5.x/html/index.html#) is quite extensive. To give you a bit of a flavour of it, let's import the module:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport rpy2\nrpy2.__version__\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'3.5.4'\n```\n:::\n:::\n\n\nThis does not in itself give us access to R. In order to call R code rpy2 needs to start R as a child process, and that doesn't happen until we import `rpy2.robjects`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport rpy2.robjects as robjects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\f\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.1 (2022-06-23) ðŸŒˆ\n```\n:::\n:::\n\n\nYou'll notice that this prints a little startup message. If you're following along at home you'll probably see something different: you're most likely to see the typical R startup message. The only reason it's truncated on my machine is that I've modified my `.Rprofile` so that R is less chatty on start up. Also I added a pretty little rainbow because why not?^[As an aside, it's worth noting that rpy2 has run R with my standard configuration. It hasn't loaded any specific environment. I was half tempted to talk about how you a Python user could use rpy2 to configure the R environment using the [renv](https://rstudio.github.io/renv/index.html) package for instance, but that felt a little beyond the scope of the post. The only thing I will mention is that in this particular use case (passing Arrow objects between R and Python) I would not recommend trying to configure the Python environment and the R environment within the same conda environment. I tried this and oh my... the number of unsolvable conflicts was truly impressive. Keep the Python environment and the R environment separate babes.] Normally you'd see a more verbose startup message from R but I prefer to keep mine quieter so all it does is print the version string and a pretty little rainbow. \n\nAnyway, our next step is to load some packages. In native R code we'd use the `library()` function for this, but rpy2 provides a more Pythonic approach. Importing the packages submodule gives us acces to `importr()`, which is allows us to load packages. The code below illustrates how you can expose the base R package and the utils R package (both of which come bundled with any minimal R installation) to Python:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport rpy2.robjects.packages as rpackages\n\nbase = rpackages.importr(\"base\")\nutils = rpackages.importr(\"utils\")\n```\n:::\n\n\nOf particular note is that once we have access to utils we can call the native R function `install.packages()` to install additional packages from CRAN. However, at this point we need to talk a little about how names are translated by rpy2. As every Python user would note, the dot is special and not used within the name of a function. Though not generally recommended in R except in special circumstances,^[The dot is typically used to denote an [S3](https://adv-r.hadley.nz/s3.html) method in R, but because R embraces chaos this is not universally adhered to and in any case S3 is... look, I love S3 but as Hadley Wickham once observed it's an object oriented programming system that absolutely allows you to shoot yourself in the foot if you want to. Anyway. This is not the post for ramblings about the chaotic splendour of R.] functions containing dots (and various other characters not permitted by Python) are syntactically valid in R. To address this, rpy2 will automatically convert dots to underscores. So if I want to install the fortunes package -- a toy package that contains various quotes vaguely related to R -- using rpy, this is how I'd do it:^[Depending on how blank your R configuration is, you may need to specify which CRAN mirror you want to download the package from before attempting the installation. To do that, include a command like `utils.chooseCRANmirror(ind=1)` to select the first mirror on the list of known servers.]\n\n``` python\nutils.install_packages(\"fortunes\")\n```\n\nOnce installed the fortunes package can be imported, allowing me to call the `fortune()` function from the package:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfortunes = rpackages.importr(\"fortunes\")\nfortune = fortunes.fortune(7)\nprint(fortune)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nWhat we have is nice, but we need something very different.\n   -- Robert Gentleman\n      Statistical Computing 2003, Reisensburg (June 2003)\n\n\n```\n:::\n:::\n\n\nI'm rather fond of this quote, and it seems very appropriate to the spirit underpinning polyglot data science. Whatever language or tools we're working in, we've usually chosen them for good reason.^[Seriously. Few things in life annoy me more than \"language wars\". Digging your heels in over the perceived superiority of your preferred tool is rarely a useful way to spend your time.] Sometimes though, we need access to something very different, and we want our tools to be able to talk fluently to each other.\n\nIn any case, although we've barely scratched the surface of what rpy2 is capable of, we're now at the point where we can start tackling the problem of transferring data from Python to R. To do that, however, we'll need some data.\n\n## About the data \n\nThe data set for this post comes from the [To Be Continued](https://cdhrdatasys.anu.edu.au/tobecontinued/) database of fiction published in Australian newspapers during the 19th and early 20th century. Originally collected using the incredibly cool [Trove](https://trove.nla.gov.au/) resource run by the National Library of Australia, it's released under a CC-BY-4.0 licence and maintained by Katherine Bode and Carol Hetherington. To get a sense of what the data looks like, let's use pandas to load the data set and inspect the first few rows:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport pandas\n\nfiction = pandas.read_csv(\"fiction.csv\", low_memory = False)\nfiction.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Trove ID</th>\n      <th>Common Title</th>\n      <th>Publication Title</th>\n      <th>Start Date</th>\n      <th>End Date</th>\n      <th>Additional Info</th>\n      <th>Length</th>\n      <th>Curated Dataset</th>\n      <th>Identified Sources</th>\n      <th>Publication Source</th>\n      <th>...</th>\n      <th>Other Names</th>\n      <th>Publication Author</th>\n      <th>Gender</th>\n      <th>Nationality</th>\n      <th>Nationality Details</th>\n      <th>Author Details</th>\n      <th>Inscribed Gender</th>\n      <th>Inscribed Nationality</th>\n      <th>Signature</th>\n      <th>Name Category</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>The Mystery of Edwin Drood</td>\n      <td>The Mystery of Edwin Drood</td>\n      <td>1871-03-04</td>\n      <td>1871-06-03</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>Y</td>\n      <td>LCVF</td>\n      <td>NaN</td>\n      <td>...</td>\n      <td>NaN</td>\n      <td>Dickens, Charles</td>\n      <td>Male</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>LCVF</td>\n      <td>Male</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>Attributed</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>The Mystery of Edwin Drood</td>\n      <td>The Mystery of Edwin Drood</td>\n      <td>1871-03-07</td>\n      <td>1871-05-16</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>Y</td>\n      <td>LCVF</td>\n      <td>NaN</td>\n      <td>...</td>\n      <td>NaN</td>\n      <td>Dickens, Charles</td>\n      <td>Male</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>LCVF</td>\n      <td>Male</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>Attributed</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>Sporting Recollections in Various Countries</td>\n      <td>Sporting Recollections in Various Countries</td>\n      <td>1847-06-16</td>\n      <td>1847-07-07</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>Y</td>\n      <td>WPEDIA</td>\n      <td>Sunday Times</td>\n      <td>...</td>\n      <td>NaN</td>\n      <td>Viardot, M. Louis</td>\n      <td>Male</td>\n      <td>French</td>\n      <td>NaN</td>\n      <td>WPEDIA</td>\n      <td>Male</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>Attributed</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>Brownie's Triumph</td>\n      <td>The Jewels</td>\n      <td>1880-05-08</td>\n      <td>1880-08-14</td>\n      <td>NaN</td>\n      <td>0.0</td>\n      <td>Y</td>\n      <td>TJW</td>\n      <td>NaN</td>\n      <td>...</td>\n      <td>Sarah Elizabeth Forbush Downs; Downs, Mrs Geor...</td>\n      <td>Unattributed</td>\n      <td>Female</td>\n      <td>American</td>\n      <td>NaN</td>\n      <td>WPEDIA</td>\n      <td>Uninscribed</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>Unattributed</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>The Forsaken Bride</td>\n      <td>Abandoned</td>\n      <td>1880-08-21</td>\n      <td>1880-12-18</td>\n      <td>Fiction. From English, American and Other Peri...</td>\n      <td>0.0</td>\n      <td>Y</td>\n      <td>TJW</td>\n      <td>NaN</td>\n      <td>...</td>\n      <td>Sarah Elizabeth Forbush Downs; Downs, Mrs Geor...</td>\n      <td>Unattributed</td>\n      <td>Female</td>\n      <td>American</td>\n      <td>NaN</td>\n      <td>WPEDIA</td>\n      <td>Uninscribed</td>\n      <td>British</td>\n      <td>NaN</td>\n      <td>Unattributed</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows Ã— 28 columns</p>\n</div>\n```\n:::\n:::\n\n\nWe can take a look at the distribution of nationalities among published authors too. The table below counts the number of distinct publications (Trove IDs) and authors for each nationality represented in the data:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfiction[[\"Nationality\", \"Trove ID\", \"Publication Author\"]]. \\\n  groupby(\"Nationality\"). \\\n  nunique()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Trove ID</th>\n      <th>Publication Author</th>\n    </tr>\n    <tr>\n      <th>Nationality</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>American</th>\n      <td>3399</td>\n      <td>618</td>\n    </tr>\n    <tr>\n      <th>Australian</th>\n      <td>4295</td>\n      <td>757</td>\n    </tr>\n    <tr>\n      <th>Australian/British</th>\n      <td>95</td>\n      <td>12</td>\n    </tr>\n    <tr>\n      <th>Austrian</th>\n      <td>3</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>British</th>\n      <td>10182</td>\n      <td>1351</td>\n    </tr>\n    <tr>\n      <th>British/American</th>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Canadian</th>\n      <td>185</td>\n      <td>29</td>\n    </tr>\n    <tr>\n      <th>Dutch</th>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>English</th>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>French</th>\n      <td>187</td>\n      <td>64</td>\n    </tr>\n    <tr>\n      <th>German</th>\n      <td>39</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>Hungarian</th>\n      <td>2</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Irish</th>\n      <td>63</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>Italian</th>\n      <td>12</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Japanese</th>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Multiple</th>\n      <td>3</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>New Zealand</th>\n      <td>67</td>\n      <td>23</td>\n    </tr>\n    <tr>\n      <th>Polish</th>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Russian</th>\n      <td>18</td>\n      <td>13</td>\n    </tr>\n    <tr>\n      <th>Scottish</th>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>South African</th>\n      <td>14</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Swedish</th>\n      <td>1</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Swiss</th>\n      <td>2</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>United States</th>\n      <td>2</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Unknown</th>\n      <td>13133</td>\n      <td>2692</td>\n    </tr>\n    <tr>\n      <th>Unknown, not Australian</th>\n      <td>882</td>\n      <td>88</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNow that we have a sense of the data, let's add Arrow to the mix!\n\n## Panda to Arrow Table\n\nI'm relatively new to working with Arrow data on the Python side, but I'm pleased to discover that it's straightforward to construct an Arrow Table from a Pandas DataFrame using pyarrow. Here's how we do that:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport pyarrow\n\npyarrow_fiction = pyarrow.Table.from_pandas(fiction)\npyarrow_fiction\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\npyarrow.Table\nTrove ID: int64\nCommon Title: string\nPublication Title: string\nStart Date: string\nEnd Date: string\nAdditional Info: string\nLength: double\nCurated Dataset: string\nIdentified Sources: string\nPublication Source: string\nNewspaper ID: int64\nNewspaper: string\nNewspaper Common Title: string\nNewspaper Location: string\nNewspaper Type: string\nColony/State: string\nAuthor ID: int64\nAuthor: string\nOther Names: string\nPublication Author: string\nGender: string\nNationality: string\nNationality Details: string\nAuthor Details: string\nInscribed Gender: string\nInscribed Nationality: string\nSignature: string\nName Category : string\n----\nTrove ID: [[1,2,3,4,5,...,35491,35492,35493,35494,35495]]\nCommon Title: [[\"The Mystery of Edwin Drood\",\"The Mystery of Edwin Drood\",\"Sporting Recollections in Various Countries\",\"Brownie's Triumph\",\"The Forsaken Bride\",...,\"The Heart of Maureen\",\"His Lawful Wife\",\"Love's Reward\",\"Only a Flirt\",\"The Doctor's Protegee\"]]\nPublication Title: [[\"The Mystery of Edwin Drood\",\"The Mystery of Edwin Drood\",\"Sporting Recollections in Various Countries\",\"The Jewels\",\"Abandoned\",...,\"The Heart of Maureen\",\"His Lawful Wife\",\"Love's Reward\",\"Only a Flirt\",\"The Doctor's Protegee\"]]\nStart Date: [[\"1871-03-04\",\"1871-03-07\",\"1847-06-16\",\"1880-05-08\",\"1880-08-21\",...,\"1914-01-06\",\"1912-10-26\",\"1911-02-04\",\"1916-05-06\",\"1911-11-25\"]]\nEnd Date: [[\"1871-06-03\",\"1871-05-16\",\"1847-07-07\",\"1880-08-14\",\"1880-12-18\",...,\"1914-01-06\",\"1912-10-26\",\"1911-02-04\",\"1916-05-06\",\"1911-11-25\"]]\nAdditional Info: [[null,null,null,null,\"Fiction. From English, American and Other Periodicals\",...,\"Published by special arrangement. All rights reserved.\",\"Published by special arrangement. All rights reserved.\",\"Published by special arrangement. All rights reserved.\",\"All  Rights Reserved\",\"Published by special arrangement. All rights reserved.\"]]\nLength: [[0,0,0,0,0,...,0,0,0,0,0]]\nCurated Dataset: [[\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",...,\"N\",\"N\",\"N\",\"N\",\"N\"]]\nIdentified Sources: [[\"LCVF\",\"LCVF\",\"WPEDIA\",\"TJW\",\"TJW\",...,null,null,null,null,null]]\nPublication Source: [[null,null,\"Sunday Times\",null,null,...,null,null,null,null,null]]\n...\n```\n:::\n:::\n\n\nThe output looks about right to me. It's formatted slightly differently from what I expect when I'm working with Arrow Tables in R, but this is most definitely an Arrow Table, displayed according to pyarrow conventions. \n\nNow that we have our data represented as an Arrow Table, we can move onto the really fun part... seamlessly handing the reins back and forth between Python and R without ever making copies of the data object. \n\n## Passing Tables from Python to R\n\nTo pass Arrow objects between Python and R, rpy2 needs a little help because it doesn't know how to handle Arrow data structures on its own. That's where the [rpy2-arrow module](https://rpy2.github.io/rpy2-arrow/version/main/html/index.html) comes in handy. I'll quote from the package documentation here:\n\n> The package allows the sharing of Apache Arrow data structures (Array, ChunkedArray, Field, RecordBatch, RecordBatchReader, Table, Schema) between Python and R within the same process. The underlying C/C++ pointer is shared, meaning potentially large gain in performance compared to regular arrays or data frames shared between Python and R through the conversion rules included in rpy2. \n\nAs with rpy2 itself, I'm not going to attempt a proper tutorial in this post, and instead just restrict myself to showing you how to solve the problem at hand. We want to first import the conversion tools from rpy_arrow:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport rpy2_arrow.pyarrow_rarrow as pyra\n```\n:::\n\n\nHaving done that, we use the `pyarrow_to_r_table()` function to pass an Arrow Table from Python to R, like so:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nrarrow_fiction = pyra.pyarrow_to_r_table(pyarrow_fiction)\nrarrow_fiction\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<rpy2.robjects.environments.Environment object at 0x7f1a9eac3740> [RTYPES.ENVSXP]\nR classes: ('Table', 'ArrowTabular', 'ArrowObject', 'R6')\nn items: 36\n```\n:::\n:::\n\n\nThe printed output isn't the prettiest thing in the world, but nevertheless it does represent the object of interest. On the Python side we have `pyarrow_fiction`, a data structure that points to an Arrow Table and enables various compute operations supplied through pyarrow. On the R side we now have `rarrow_fiction`, a data structure that points to the *same* Arrow Table and enables compute operations supplied by the R arrow package. \n\n## Accessing the Table from the R side\n\nWe're almost done, but the tour isn't really complete until we've stepped out of Python entirely, manipulated the object on the R side, and then passed something back to Python. So let's do that next.\n\nIn order to pull off that trick within this quarto document -- which is running jupyter under the hood -- we'll need to use a little notebook magic. The rpy2 module supplies an [interface for interactive work](https://rpy2.github.io/doc/latest/html/interactive.html) that we can enable in a notebook context like this: \n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n%load_ext rpy2.ipython\n```\n:::\n\n\nNow that we've done this, all I have to do is preface each cell with `%%R` and the subsequent \"Python\" code will be passed to R and interpreted there.^[Okay, so some R users might be wondering about what was going on in the last post where I was flipping back and forth between R and Python without apparently doing anything like this. The answer is that when using knitr as the engine (rather than jupyter), python code is automatically interpreted with the help of reticulate. That's already a feature in knitr, so I didn't need to invoke it explicitly.] To start with I'll load the dplyr and arrow packages, using `suppressMessages()` to prevent them being chatty and warning me about namespace masking: \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n%%R\nsuppressMessages({\n  library(dplyr)\n  library(arrow)\n})\n```\n:::\n\n\nNow that I've done that, I'll use the dplyr/arrow toolkit to do a little data wrangling on the `rarrow_fiction` Table. I'm not doing anything fancy, just a little cross-tabulation counting the joint distribution of genders and nationalities represented in the data using the `count()` function, and using `arrange()` to sort the results. The part that actually matters for our purposes is the first line:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n%%R -i rarrow_fiction\ngender <- rarrow_fiction |> \n  count(Gender, Nationality) |>\n  arrange(desc(n)) |>\n  compute()\n  \ngender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTable\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n63 rows x 3 columns\n$Gender <string>\n$Nationality <string>\n$n <int64>\n\nSee $metadata for additional Schema metadata\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n```\n:::\n:::\n\n\nBy using `%%R -i rarrow_fiction` to specify the cell magic, we're able to access the `rarrow_fiction` object from R within this cell and perform the required computations. \n\n## The journey home\n\nWe now have an object in the embedded R session that we might wish to access from the Python session and convert to a Python object: first an Arrow Table and then possibly a Pandas DataFrame. Here's how that process works. If you recall from earlier in the post, we imported `robjects` to start the embedded R session. When we did so, we also exposed `robjects.r`, which provides access to all objects within that R session. For instance, to create a Python object `r_gender` that refers to the R data structure we created in the last section, here's what we'd do:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nr_gender = robjects.r('gender')\nr_gender\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n<rpy2.robjects.environments.Environment object at 0x7f1aaf704a40> [RTYPES.ENVSXP]\nR classes: ('Table', 'ArrowTabular', 'ArrowObject', 'R6')\nn items: 36\n```\n:::\n:::\n\n\nNotice that this is the same object. The `r_gender` variable refers to the Arrow Table in R: it's not a pyarrow table. If we want to convert it to a data structure that pyarrow understands, we can use pyra to make the conversion. It supplies an `rarrow_to_py_table()` function that is suitable for our purposes:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\npy_gender = pyra.rarrow_to_py_table(r_gender)\npy_gender\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\npyarrow.Table\nGender: string\nNationality: string\nn: int64\n----\nGender: [[\"Unknown\",\"Male\",\"Female\",\"Male\",\"Female\",...,\"Both\",\"Female\",\"Female\",\"Female\",null]]\nNationality: [[\"Unknown\",\"British\",\"British\",\"Australian\",\"Australian\",...,\"Australian/British\",\"British/American\",\"South African\",\"Polish\",\"Australian\"]]\nn: [[12832,6420,3346,2537,1687,...,1,1,1,1,1]]\n```\n:::\n:::\n\n\nJust like that, we've handed over the Arrow Table from R back to Python. If we really want to, we can now convert this back to a Pandas DataFrame using pyarrow:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\npanda_gender = pyarrow.Table.to_pandas(py_gender)\npanda_gender\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Gender</th>\n      <th>Nationality</th>\n      <th>n</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Unknown</td>\n      <td>Unknown</td>\n      <td>12832</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Male</td>\n      <td>British</td>\n      <td>6420</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Female</td>\n      <td>British</td>\n      <td>3346</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Male</td>\n      <td>Australian</td>\n      <td>2537</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Female</td>\n      <td>Australian</td>\n      <td>1687</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>58</th>\n      <td>Both</td>\n      <td>Australian/British</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>59</th>\n      <td>Female</td>\n      <td>British/American</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>60</th>\n      <td>Female</td>\n      <td>South African</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>61</th>\n      <td>Female</td>\n      <td>Polish</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>62</th>\n      <td>None</td>\n      <td>Australian</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>63 rows Ã— 3 columns</p>\n</div>\n```\n:::\n:::\n\n\nAnd with that the journey is complete!\n\n## Acknowledgements {.appendix}\n\nIn writing this post I am heavily indebted to Isabella VelÃ¡squez, whose fabulous post on [calling R from Python with rpy2](https://rviews.rstudio.com/2022/05/25/calling-r-from-python-with-rpy2/) helped me immensely. The [documentation on integrating PyArrow with R](https://arrow.apache.org/docs/python/integration/python_r.html) was extremely helpful too!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}