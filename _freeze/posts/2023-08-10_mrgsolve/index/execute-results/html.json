{
  "hash": "2dfbeb041e6a37968cddef89aff8fbea",
  "result": {
    "markdown": "---\ntitle: \"mrgsolve\"\ndescription: \"This is a subtitle\"\ndate: \"2023-08-10\"\n--- \n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nContinuing my informal series of \"Danielle learns [pharmacometric modelling](https://blog.djnavarro.net/category/pharmacometrics)\" posts, today I've decided to sit down and teach myself how to use the [mrgsolve](https://mrgsolve.org/) package in R.\n\nAs I'm rapidly coming to realise, the world of pharmacometric modelling is an intersting space where there are a large number of domain-specific languages that have been designed to solve a particular subset of the modelling problems faced by analysts in the field, and R serves as a lingua franca that stitches them all together and makes it possible to write analysis scripts that call on multiple tools.^[In this respect R is the unchallenged queen of languages in pharmacometrics. It's very different to data science in the tech space, where Python is the lingua franca and R is seen as a second-class citizen. I have not yet seen a single example of anyone using Python for data analysis in this world. Judging from papers I've read, Julia has a small presence (e.g., you can use Turing.jl for building ODE models in Julia), but that's the only time I've ever seen any statistical language other than R in this space.] \n\nWith that as the structure of the ecosystem, what you tend to find are packages that carve out a specific niche by building on top of some other tool. For this post, the niche we're talking about is **model-based simulation**. In this context, it's assumed that the analyst has a specific pharmacometric model in mind (e.g., one-compartment PK model,^[The acronym PK is universally used as shorthand for \"pharmacokinetics\", and a PK model is one where the primary variable you're interested in modelling is the plasma concentration over time for some drug. If you're totally new to this space, the post I wrote on [non-compartmental analysis](/posts/2023-04-26_non-compartmental-analysis/) was written from a total-newbie perspective and spells out a lot the basic terminology used in PK modelling.] two-compartment PK model, etc etc). We are not attempting to estimate parameters from data, nor are we runing a model testing exercise. The model is presumed to exist already, usually because the analyst has already done the model fitting exercise using their tool of choice.^[There are a *lot* of tools in this space: NONMEM is the oldest and most-widely used, but in addition there's Stan/Torsten, Monolix, nlmixr, Phoenix NLME, and probably many others I don't know about yet...]\n\nWithin the specific \"model simulation\" niche there are a number of R packages that people seem to use frequently. There's the RxODE package^[I'm can't tell if the original package is still under active development or if it's been deprecated. The [RxODE](https://nlmixrdevelopment.github.io/RxODE/) package still appears on the nlmixr website and on GitHub, but the package is (at present?) archived on CRAN.] and its successor [rxode2](https://nlmixr2.github.io/rxode2/), for example, and mrgsolve falls within the same general niche. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mrgsolve)\n```\n:::\n\n\n## A simple example\n\nOkay, let's get started. When I started looking into mrgsolve, the place I started was with the vignettes on the package website, so I'll start this post by using a simple modelling example taken from the [get started](https://mrgsolve.org/vignettes/01-get-started.html) page. \n\nThe way mrgsolve is designed allows you to write your own custom models, and later in the post I'll talk about how this is done, but it also comes with a collection of predefined models that you can access using the `modlib()` function. So I'll start there: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"pk1\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBuilding pk1 ... done.\n```\n:::\n:::\n\n\nIn this code, `\"pk1\"` refers to the name of one of the model that comes bundled with mrgsolve... and there will be exactly zero pharmacometricians in this world that are surprised to discover that this is a one-compartment PK model with first-order absorption into the central compartment, and first-order elimination from the central compartment. To see what parameters are used in this version of the model we can call `param()`...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n Model parameters (N=3):\n name value . name value\n CL   1     | V    20   \n KA   1     | .    .    \n```\n:::\n:::\n\n\n...and we see that out model assumes a clearance (CL) of 1, an aborption rate constant (KA) of 1, and a volume of distribution equal to 20. The mrgsolve package doesn't keep track of units: it's up to the user to make sure all the units are on the appropriate scale. \n\nThe message printed to the console is probably equally unsurprising, but I'll be good and explain it. The mrgsolve package is build on top of an open source ODE solver,^[Specifically, it wraps the public domain Fortran library [ODEPACK](https://computing.llnl.gov/projects/odepack)] but the user doesn't need to call it directly. Instead, a model is constructed using a model specification file (more on that later) that is then compiled to C++. This compiled model is used to run simulations, and it's this compiled model that calls the ODE solvers. So when I called `modlib(\"pk1\")`, it reads the model specification file and builds the compiled model.^[As far as I can tell, the mrgsolve package builds on a per-session basis, so if I were to repeat the same command in the R session that knits this blog post, I'd see a different message informing me that mrgsolve is using the cached version of the compiled model.]\n\nOkay so now we have a model object `mod` that specifies all our pharmacokinetic assumptions. In order to run a simulation, we also need to provide an **event schedule** that provides dosing information, and we'll also need to say something about the time points at which we want to simulate the various pharmacokinetic quantities of interest. You can do this in a few different ways (which I'll get to momentarily) but for the purposes of the initial example I'll do it the same way that the \"get started\" vignette does, use a pipe-friendly workflow: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod |> \n  ev(amt = 100, ii = 24, addl = 9) |>\n  mrgsim(start = 0, end = 480, delta = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel:  pk1 \nDim:    4802 x 5 \nTime:   0 to 480 \nID:     1 \n    ID time     EV   CENT     CP\n1:   1  0.0   0.00  0.000 0.0000\n2:   1  0.0 100.00  0.000 0.0000\n3:   1  0.1  90.48  9.492 0.4746\n4:   1  0.2  81.87 18.034 0.9017\n5:   1  0.3  74.08 25.715 1.2858\n6:   1  0.4  67.03 32.619 1.6309\n7:   1  0.5  60.65 38.819 1.9409\n8:   1  0.6  54.88 44.383 2.2191\n```\n:::\n:::\n\n\nHere we take the `mod` object, pipe it to the `ev()` function that builds the event schedule, and then pipe the output to `mrgsim()` which then runs the simulation. In this code, the arguments to `ev()` are all very standard in the field:\n\n- `amt` is the amount of drug\n- `ii` is the interdose interval\n- `addl` is number of additional doses\n\nThe arguments to `mrgsim()` are used to specify the time points:\n\n- `start` is the initial time point (I actually didn't need to specify it in ths case because the default value is 0)\n- `end` is the final time point\n- `delta` is the step size (i.e., the amount of time between successive time points)\n\nThe output here is a tabular data structure -- not technically a data frame, but I'll get to that -- with sensible column names: \n\n- `ID` is a subject identifier (always 1 for this simple example)\n- `time` is the time point for the simulated measurement\n- `EV` is the drug amount in the extravascular compartment (e.g., the gut, if we're talking about oral dosing)\n- `CENT` is the drug amount in the central compartment\n- `CP` is the drug concentration in the central compartment\n\nTo help you get a sense of what the simulation results look like, the mrgsolve package provides a plot method for simulation results, so if I'd wanted to I could add a call to `plot()` at the end of the pipeline, and get this as the output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod |> \n  ev(amt = 100, ii = 24, addl = 9) |>\n  mrgsim(start = 0, end = 480, delta = 0.1) |>\n  plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nVery nice.\n\n## Unpacking the example\n\nNow things get a little messier. Under the hood the mrgsolve package is doing quite a lot of magic to make it all work, and there are some design choices here that you need to be aware of if you're planning to call mrgsolve functions programmatically. In particular, some of the functions -- by design -- do not produce [type stable output](https://design.tidyverse.org/out-type-stability.html), so some care is involved if you're going to write automations around them or call mrgsolve from another package.^[I should say, for the record, that I'm not being critical here. Software developers who don't work in statistics have a tendency to get very angry at R (and R developers) for writing hyper-flexible functions that produce wildly different output types depending on the input. While I do understand that annoyance, I also think it's often misplaced. R is fundamentally a *statistical programming language*. It's not trying to be Python, and it's even less interested in being Rust. You wouldn't think it from browsing the \"rstats\" hashtag on social media (which is massively biased towards developers), but the typical R user is someone working interactively at the console, constructing a script iteratively as they explore and work with the data set they've been tasked to analyse. In that context, the hyper-flexibility of a lot of R functions is designed for the convenience of the *analyst*. It's not there for your convenience as a developer. Of course, I also think that package developers should always ensure that there are type-stable versions of their functions that other R developers can call in package code, but... for example, mrgsolve does in fact support this. If you're a developer calling `mrgsolve::modlib()` from within a package then IMO you don't get to whine about mrgsolve doing it wrong. In that scenario you get what you deserve for writing *your* package the wrong way.] \n\n### The model library\n\nLet's start by taking a closer look at the library of pre-specified models that come bundled with mrgsolve. They're stored in a package folder whose location is accessible by calling `modlib()` with no arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models\"\n```\n:::\n:::\n\n\nAs you can see, when called with no inputs `modlib()` doesn't return a compiled model, and it simply returns the path to the model library folder. If you want a list of the models that come bundled with mrgsolve, you can call `modlib()` setting `list = TRUE`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib(list = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nmrgsolve internal library:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n  effect  tmdd  viral1  viral2  emax  irm1  irm2  irm3  irm4  pk1cmt  pk2cmt  pk3cmt  pk1  pk2  pk2iv  popex  pred1  pbpk  1005  nm-like\n```\n:::\n:::\n\n\nFinally, if you want to build and use one of these model you can call `modlib()` and pass the name of the model you want as the `model` argument:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(model = \"pk1\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading model from cache.\n```\n:::\n:::\n\n\nIf you're working interactively or with a script that isn't going to be repeatedly reused with different inputs, the `modlib()` function is pretty handy. On the other hand if you're a developer calling mrgsolve programmatically it's probably better to rely on a different workflow. For instance, if you want to access the mrgsolve package folder that contains the models, you'd do something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::path_package(\"mrgsolve\", \"models\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models\n```\n:::\n:::\n\n\nIf you want to construct file paths to the various model specification files contained within the package, you probably want to find paths to all the `.cpp` files in the model folder:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib_dir <- fs::path_package(\"mrgsolve\", \"models\")\nmodlib_cpp <- fs::dir_ls(modlib_dir, regexp = \"\\\\.cpp$\")\nmodlib_cpp\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/1005.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/effect.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/emax.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/irm1.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/irm2.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/irm3.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/irm4.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/nm-like.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pbpk.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk1.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk1cmt.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk1cmt_pop.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk2.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk2cmt.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk2iv.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pk3cmt.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pkExample.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/popex.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/pred1.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/tmdd.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/viral1.cpp\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models/viral2.cpp\n```\n:::\n:::\n\n\nEasy done. \n\n\n### Building models from file\n\nBuilding one of the bundled models using `modlib()` is a perfectly sensible thing to do when you're working interactively or when you're just starting out with mrgsolve, but after a while you might want to pivot to a different workflow. To that end, there's an `mread()` function -- and related functions `mread_file()` and `mread_cache()` -- that reads a model specification file and returns the model object linked to the compiled code. As an example, here's how I'd build the one-compartment model in the previous section, except using `mread()` this time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- mread(model = \"pk1\", project = modlib_dir)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBuilding pk1 ... (waiting) ...\ndone.\n```\n:::\n:::\n\n\nOptionally you can provide a file name for the model specification file that sits within the `project` folder, but in this case we don't need to: if the `file` argument is unspecified `mread()` assumes that the file name is the same as the `model` name with file extension `.cpp`.^[Developers reading this are probably wondering where the model shared object ends up when compilation happens. By default `mread()` puts the compiled model in the R temp folder, but you can override this in a persistent way by setting the `\"mrgsolve.soloc\"` option, or overriding it in the call to `mread()` via the `soloc` argument. You can also suppress compilation if you want bt setting `compile = FALSE`. But probably any devs reading this would likely discover that within 5 minutes of reading the documentation anyway so there's no real need for me to mention it.]\n\n### Model objects\n\nThe mrgsolve package is built using S4 classes and of the great many object oriented programming systems available in R that's the one I'm least comfortable with.^[I mean... of the *widely-used* OOP systems, it's the one I'm least comfortable with. The wild abandon with which R spawns new object oriented programming systems is... a lot to keep up with. Honestly it's exhausting.] But hey... I've just reread the [S4 chapter in Advanced R](https://adv-r.hadley.nz/s4.html), so let's see how we go with this, shall we? First, I'll be polite and explicitly load the methods package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(methods)\n```\n:::\n\n\nNext let's see what kind of object `mod` is and what methods are defined for it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"mrgmod\"\n```\n:::\n\n```{.r .cell-code}\nmethods(class = \"mrgmod\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] [              [[             $              all.equal     \n [5] as.environment as.list        blocks         cmtn          \n [9] data_set       ev_rx          ev             evd           \n[13] idata_set      init           initialize     knobs         \n[17] loadso         names          omat           param         \n[21] req            Req            revar          see           \n[25] show           smat           stime          summary       \n[29] update         within         zero_re       \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\nA lot of those methods are unsurprising. For example, the `show()` method is just the S4 analog of `print()`. When we print the `mod` object at the console we're just calling its `show()` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n-----------------  source: pk1.cpp  -----------------\n\n  project: /home/danielle/R...gsolve/models\n  shared object: pk1-so-15d117408c12e \n\n  time:          start: 0 end: 24 delta: 1\n                 add: <none>\n\n  compartments:  EV CENT [2]\n  parameters:    CL V KA [3]\n  captures:      CP [1]\n  omega:         0x0 \n  sigma:         0x0 \n\n  solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n------------------------------------------------------\n```\n:::\n:::\n\n\nBut there are other methods that are kind of handy when inspecting a mrgmod object. For example, if we wanted to see the source code for the corresponding model specification file we could call the `see()` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsee(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nModel file:  pk1.cpp \n$PARAM @annotated\nCL   :  1 : Clearance (volume/time)\nV    : 20 : Central volume (volume)\nKA   :  1 : Absorption rate constant (1/time)\n\n$CMT  @annotated\nEV   : Extravascular compartment\nCENT : Central compartment\n\n$GLOBAL\n#define CP (CENT/V)\n\n$PKMODEL ncmt = 1, depot = TRUE\n\n$CAPTURE @annotated\nCP : Plasma concentration (mass/volume)\n```\n:::\n:::\n\n\nIf we didn't want quite that much detail, a `summary()` would have sufficed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel: pk1\n- Parameters: [3]\n  CL, V, KA\n- Compartments: [2]\n  EV, CENT\n- Captured: [1]\n  CP\n- Outputs: [3]\n  EV, CENT, CP\n```\n:::\n:::\n\n\nI don't intend to do an exhaustive walk through of all the methods defined for mrgmod objects. That would be tiresome, and in any case I don't even know what all of them do yet. But what I will mention is that many of the methods exist to provide public accessors for these internal slots of a mrgmod object. To illustrate, here's a list of all the slot names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslotNames(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"model\"    \"modfile\"  \"package\"  \"soloc\"    \"project\"  \"start\"   \n [7] \"end\"      \"delta\"    \"add\"      \"tscale\"   \"digits\"   \"quiet\"   \n[13] \"verbose\"  \"debug\"    \"preclean\" \"atol\"     \"rtol\"     \"ss_rtol\" \n[19] \"ss_atol\"  \"maxsteps\" \"hmin\"     \"hmax\"     \"ixpr\"     \"mxhnil\"  \n[25] \"shlib\"    \"funs\"     \"omega\"    \"sigma\"    \"request\"  \"param\"   \n[31] \"init\"     \"capture\"  \"Icap\"     \"capL\"     \"Icmt\"     \"cmtL\"    \n[37] \"args\"     \"fixed\"    \"advan\"    \"trans\"    \"mindt\"    \"code\"    \n[43] \"annot\"    \"envir\"    \"plugin\"   \"ss_cmt\"  \n```\n:::\n:::\n\n\nOkay so one of the slots is called \"param\", and denoted `@param` to remind us that it's a slot of an S4 object.^[Why yes, this blog post is *also* an exercise in \"Danielle reminds herself how S4 works and no she bloody well is not going to talk about multiple inheritance and multiple dispatch in S4 here she's not that much of a masochist\".] Calling the `param()` method is the appropriate way to access the `@param` slot, for instance.^[As an aside, `param(mod)` returns an S4 object of class \"parameter_list\" which in turn has a `show()` method that provides that prettified looking table pf parameters, but from a practical perspective you might just want to coerce it to a regular list using `as.list(param(mod))`.] \nThe `see()` method is slightly fancier, but it too is essentially an accessor function for the `@modelfile` and `@code` slots. If I were an extremely unwise woman who ignored all the best practices for S4 classes I could use a command like `cat(mod@code, sep = \"\\n\")` and get roughly the same output. This is of course a terrible idea: the slots of an S4 object are considered internal details and not part of the package API. Accessing them directly is considered a faux pas and you have only yourself to blame if the developer later changes the structure of the slots and your code breaks. \n\nIndeed, the *only* reason I'm talking about them here is that I find it helpful for building my own mental model of what mrgsolve does, which will become apparent in the next section when I tackle the puzzlingly magical behaviour of the `ev()` function. \n\n### Event objects\n\nModel objects represent the underlying ODE system. They don't store information about \"interventions\" (external forcers) on the system. In the pharmacokinetic context the main intervention we're thinking about is dosing. An events object returned by `ev()` returns a event schedule that would be familiar to NONMEM users^[I really need to *learn* NONMEM. It's becoming a bit absurd that I'm learning everything else before NONMEM. Oh well, I was never someone to do things in the proper order.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevents <- ev(amt = 100, ii = 24, addl = 9)\nevents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    9   1    1\n```\n:::\n:::\n\n\nThe `events` object looks a lot like a data frame, but is technically an S4 object with class \"ev\". However, an ev object has only two slots, one of which is `@data` and -- as you'd expect -- it stores the data set as a data frame internally. So... yeah, it's basically a data frame, and since there are `as.data.frame()` and `as_tibble()` methods defined for ev objects, so you can coerce it to whatever your preferred form of tabular data object happens to be.^[There is also an `as.ev()` function that allows conversion in the other direction.] I'm a tibble girl myself so...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::as_tibble(events)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 6\n   time   amt    ii  addl   cmt  evid\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     0   100    24     9     1     1\n```\n:::\n:::\n\n\nI'll talk more about the fancier ways in which you can use `ev()` and the related function `data_set()` to define simulations with elaborate dosing schedule and allow variation in dosing schedules across individuals, but we're not at the point where that's necessary yet. Right now, all we're trying to do is understand what happens in the simple simulation I showed at the start of this post.\n\n### Danielle briefly loses her f**king mind\n\nOkay, it's almost time move on to `mrgsim()`, the function that we use to run the simulation itself. But we have one little matter to clear up first.\n\nEarlier I promised you a \"Danielle gets confused by `ev()`\" moment, but the previous section makes it look as if `ev()` is very simple. To see where Danielle kind of lost her mind momentarily, let's return to the \"simple\" model simulation pipeline that I used at the start of the post: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod |> \n  ev(amt = 100, ii = 24, addl = 9) |>\n  mrgsim(end = 480, delta = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel:  pk1 \nDim:    4802 x 5 \nTime:   0 to 480 \nID:     1 \n    ID time     EV   CENT     CP\n1:   1  0.0   0.00  0.000 0.0000\n2:   1  0.0 100.00  0.000 0.0000\n3:   1  0.1  90.48  9.492 0.4746\n4:   1  0.2  81.87 18.034 0.9017\n5:   1  0.3  74.08 25.715 1.2858\n6:   1  0.4  67.03 32.619 1.6309\n7:   1  0.5  60.65 38.819 1.9409\n8:   1  0.6  54.88 44.383 2.2191\n```\n:::\n:::\n\n\nIf you're expecting `ev()` to return an \"ev\" object, this pipeline makes absolutely no sense whatsoever. An ev object like `events` simply does not have the information required to run the simulations, so... something weird is happening. It shouldn't work, but it does???\n\nI cried briefly. Then I read the [documentation](https://mrgsolve.org/docs/reference/ev.html) properly. Then I cried some more. \n\nAfter reading the documentation carefully, I now understand what's going on here, but an explanation is required because if you don't look closely it looks like magic. Recall from earlier in the post I mentioned that `modlib()` is not type stable: you get qualitatively different results depending on what kind of input you pass it. The `ev()` function has the same property. When passed a model object as the first argument, it doesn't in fact return an events schedule. It returns... a model object?^[To be precise, `ev()` is an S4 generic function that does method dispatch on the `x` argument. If `x` is missing, the relevant `ev()` method returns an \"ev\" object. However, if `x` has class \"mrgmod\", the relevant method returns another \"mrgmod\" object. I'll confess this makes me a little uneasy.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nev(mod, amt = 100, ii = 24, addl = 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n-----------------  source: pk1.cpp  -----------------\n\n  project: /home/danielle/R...gsolve/models\n  shared object: pk1-so-15d117408c12e \n\n  time:          start: 0 end: 24 delta: 1\n                 add: <none>\n\n  compartments:  EV CENT [2]\n  parameters:    CL V KA [3]\n  captures:      CP [1]\n  omega:         0x0 \n  sigma:         0x0 \n\n  solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n------------------------------------------------------\n```\n:::\n:::\n\n\nLooking at the printed output, you might think that the output here is identical to the original model object `mod`, but in this case looks are deceving. The new model stores the event schedule internally: it's tucked away in the `@args` slot.^[Oh look, that apparently-irrelevant excursion she did talking about the mrgmod object slots turns out to be relevant! It's almost as if she's written things before!] To illustrate, let's assign the output to a variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_with_ev <- ev(mod, amt = 100, ii = 24, addl = 9)\n```\n:::\n\n\nNow compare the pair:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod@args\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlist()\n```\n:::\n\n```{.r .cell-code}\nmod_with_ev@args\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$events\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    9   1    1\n```\n:::\n:::\n\n\nSo now things become a little clearer. After seeing this, what you might -- correctly! -- conclude is that at the other end of the pipeline the `mrgsim()` function is aware that the event schedule might not be passed explicitly, and knows to check within the model object if that is the case. Knowing all this, we're now in a position to understand what happens during a pipeline like this: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib(\"pk1\", quiet = TRUE) |> \n  ev(amt = 100, ii = 24, addl = 9) |>\n  mrgsim(end = 480, delta = 0.1)\n```\n:::\n\n\nIt's a very clever trick, and I imagine it's something that a lot of data analysts find super handy. That said, it's not something I would want to use myself. I'm a simple girl who likes her coffee black and her functions type stable, so I'm more keen on code that looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- mrgsim_e(\n  x = mread_file(file = \"pk1.cpp\", project = modlib_dir, quiet = TRUE),\n  events = ev(amt = 100, ii = 24, addl = 9),\n  end = 480,\n  delta = 0.1\n)\n```\n:::\n\n\nNotice that: I called `mrgsim_e()` here rather than `mrgsim()`. Because mrgsolve recognises that sometimes developers might want to call it programmatically, this version of the function requires the user to pass an event object. The sneaky \"event-schedule-inside-the-model-object\" piping trick I showed at the start of the post does not work with `mrgsim_e()`, which makes it a safer choice when running simulations programmatically.^[There are several other variants on `mrgsim()` that enforce different constraints. I haven't talked about `data_set()` and related functions in this post, for instance, but there's a `mrgsim_d()` variant that requires the user to pass a data set object.] \n\nTheoretically, I suppose, there's still a risk in my code because I'm calling `ev()` and might one day forget that it has this special case, but after a bit of thought it seems pretty outlandish. I mean, yes, let's suppose I wrote a very silly function like this one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoolish_simulation <- function(...) {\n  mrgsim_e(\n    x = mread_file(file = \"pk1.cpp\", project = modlib_dir, quiet = TRUE),\n    events = ev(...),\n    end = 480,\n    delta = 0.1\n  )\n}\n```\n:::\n\n\nThis code is unwise, because the user could really mess with things depending on what gets pass to `ev()` via the dots. In the most absurd case, if the user tried to pass `x = 100` here thinking that it would add a column labelled `x` to  the event schedule^[A trick that would work perfectly well if the user wanted to add a column labelled `y`, I might add...] it would actually trigger method dispatch on the `x` object, and since `ev()` doesn't have a method for numeric-valued `x` argument, the user would receive a weird error. But this seems like a bizarre edge case -- whyyyyy would I ever write this function in the first place????? -- and *even* if the user somehow passed an mrgmod object to `ev()` in this fashion, the result is still an error: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoolish_simulation(amt = 100, ii = 24, addl = 9, x = 100)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in (function (classes, fdef, mtable) : unable to find an inherited method for function 'ev' for signature '\"numeric\"'\n```\n:::\n\n```{.r .cell-code}\nfoolish_simulation(amt = 100, ii = 24, addl = 9, x = mod)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: invalid 'events' argument\n```\n:::\n:::\n\n\nSo perhaps there's no need to worry about this outlandish scenario. Danielle wrapped herself up in knots trying to get a handle on method dispatch in `ev()`. That's not very exciting, so let's move along shall we?\n\n### Running simulations\n\nWe're almost done unpacking the simple example, but I want to rewrite the code one last time. Previously, when I called `mrgsim_e()` I passed arguments `end` and `delta` as a way to override the default assumptions about what time points we would use when running our simulations. Internally, these arguments are used to construct a \"tgrid\" object. We can construct this object explicitly by calling `tgrid()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntgrid(start = 0, end = 480, delta = 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstart:  0  end:    480  delta:  0.1  offset: 0  min:    0   max:    480 \n```\n:::\n:::\n\n\nFor the simple example, calling `tgrid()` explicitly doesn't by us much, but if you dive into the documentation a little you discover that there are tools for working with tgrid objects that allow you to define the simulation times in much richer ways than a simple grid.\n\nBut -- again -- I digress. \n\nThe real point of mentioning it here is that -- at least in my mind -- a simulation has three main components (model, events, and time points), and we now have separate functions that handle each component: we can use `mread()` to define a model, `ev()` to define an event schedule, and `tgrid()` to define the simulation times. So now, after considerable refactoring, we end up with code that looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define model, events, and times\nmod <- mread_file(file = \"pk1.cpp\", project = modlib_dir, quiet = TRUE)\nevents <- ev(amt = 100, ii = 24, addl = 9)\ntimes <- tgrid(start = 0, end = 480, delta = 0.1)\n\n# run simulation\nout <- mrgsim_e(x = mod, events = events, tgrid = times)\n```\n:::\n\n\nAll that remains is to have a look at the output we've created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel:  pk1 \nDim:    4802 x 5 \nTime:   0 to 480 \nID:     1 \n    ID time     EV   CENT     CP\n1:   1  0.0   0.00  0.000 0.0000\n2:   1  0.0 100.00  0.000 0.0000\n3:   1  0.1  90.48  9.492 0.4746\n4:   1  0.2  81.87 18.034 0.9017\n5:   1  0.3  74.08 25.715 1.2858\n6:   1  0.4  67.03 32.619 1.6309\n7:   1  0.5  60.65 38.819 1.9409\n8:   1  0.6  54.88 44.383 2.2191\n```\n:::\n:::\n\n\nAs you've probably come to expect at this point, this is not technically a data frame, it's an S4 object of class \"mrgsims\", and can easily be coerced to a data frame using `as.data.frame()` or `as_tibble()`. \n\nThe mrgsolve package supplies a plot method for mrgsims objects that generates nice looking lattice plots, making it very easy to quickly produce helpful data visualisations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(out)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nIf additional customisation is needed, however, it's pretty easy to convert the output to a tibble and then using ggplot2 to create the specific visualisation you want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nout |>\n  tibble::as_tibble() |>\n  tidyr::pivot_longer(\n    cols = c(EV, CENT, CP), \n    names_to = \"variable\", \n    values_to = \"value\"\n  ) |> \n  dplyr::mutate(\n    variable = dplyr::case_when(\n      variable == \"EV\" ~ \"Gut amount\",\n      variable == \"CENT\" ~ \"Central amount\",\n      variable == \"CP\" ~ \"Central concentration\"\n    )\n  ) |>\n  ggplot(aes(time, value)) + \n  geom_line() +\n  facet_wrap(~ variable, scales = \"free_y\") + \n  theme_bw() +\n  theme(strip.background = element_rect(fill = \"white\")) + \n  labs(\n    title = \"Drug amounts and concentrations over time\",\n    x = \"Time (hours)\",\n    y = NULL\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n## Model specification\n\nRelevant chapters in the user guide\n\n- The [model specification chapter](https://mrgsolve.org/user-guide/specification.html)\n- The [topics chapter](https://mrgsolve.org/user-guide/topics.html)\n\n### Example 1\n\n\n::: {.cell filename='example1.cpp' file='example1.cpp'}\n\n```{.cpp .cell-code  code-line-numbers=\"true\"}\n[PROB]\n\nThis is a minor variation of the \"pk2cmt\" model that is distributed as\npart of the mrgsolve internal model library. It has a single extravascular\ndosing compartment (the GUT), a central compartment (CENT), and a\nperipheral compartment (PERIPH). Absorption from GUT is first order,\nwhereas elimination from CENT follows Michaelis-Menten kinetics.\n\n[PARAM] @annotated\n\nCL   :   0  : Clearance (volume/time)\nVC   :  20  : Central volume (volume)\nQ    :   2  : Inter-compartmental clearance (volume/time)\nVP   :  10  : Peripheral volume of distribution (volume)\nKA   : 0.5  : Absorption rate constant (1/time)\nVMAX :   1  : Maximum velocity of elimination (mass/time)\nKM   :   2  : Michaelis constant for elimination (mass/volume)\n\n[CMT] @annotated\n\nGUT    : Drug amount in gut (mass)\nCENT   : Drug amount in central compartment (mass)\nPERIPH : Drug amount in peripherhal compartment (mass)\n\n[GLOBAL]\n\n#define CP (CENT / VC)          // concentration in central compartment\n#define CT (PERIPH / VP)        // concentration in peripheral compartment\n#define CLNL (VMAX / (KM + CP)) // non-linear clearance, per MM kinetics\n\n[ODE]\n\ndxdt_GUT = -KA * GUT;\ndxdt_CENT = KA * GUT - (CL + CLNL + Q) * CP  + Q * CT;\ndxdt_PERIPH = (Q * CP) - (Q * CT);\n\n[CAPTURE] @annotated\n\nCP : Plasma concentration (mass/time)\n\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- mread_file(\"example1.cpp\", quiet = TRUE)\nevents <- ev(amt = 10, ii = 24, addl = 19)\ntimes <- tgrid(start = 0, end = 960, delta = .2)\n\nout <- mrgsim_e(mod, events = events, tgrid = times)\nplot(out)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\n### Example 2\n\n\n::: {.cell filename='example2.cpp' file='example2.cpp'}\n\n```{.cpp .cell-code  code-line-numbers=\"true\"}\n[PROB]\n\nThis is a population-PK two-compartment model.\n\n[PARAM] @annotated\n\nTVVC   : 20  : Typical value for VC (volume)\nTVVP   : 10  : Typical value for VP (volume)\nTVKA   :  1  : Typical value for KA (1/time)\nTVCL   :  1  : Typical value for CL (volume/time)\nTVQ    :  2  : Typical value for Q (volume/time)\n\n[OMEGA] @annotated\n\nEVC   :   2 : Variance of random effect on VC\nEVP   :   1 : Variance of random effect on VP\nEKA   : 0.1 : Variance of random effect on KA\nECL   : 0.1 : Variance of random effect on CL\nEQ    : 0.1 : Variance of random effect on Q\n\n[MAIN]\n\ndouble VC = TVVC * exp(EVC); // central compartment volume\ndouble VP = TVVP * exp(EVP); // peripheral compartment volume\ndouble KA = TVKA * exp(EKA); // absorption rate constant\ndouble CL = TVCL * exp(ECL); // clearance\ndouble Q  = TVQ  * exp(EQ);  // intercompartmental clearance\n\n[CMT] @annotated\n\nGUT    : Drug amount in gut (mass)\nCENT   : Drug amount in central compartment (mass)\nPERIPH : Drug amount in peripherhal compartment (mass)\n\n[GLOBAL]\n\n#define CP (CENT / VC)   // concentration in central compartment\n#define CT (PERIPH / VP) // concentration in peripheral compartment\n\n[ODE]\n\ndxdt_GUT    = -(KA * GUT);\ndxdt_CENT   =  (KA * GUT) - (CL + Q) * CP + (Q * CT);\ndxdt_PERIPH =  (Q * CP) - (Q * CT);\n\n[CAPTURE] @annotated\n\nCP : Plasma concentration (mass/time)\n\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- mread_file(\"example2.cpp\", quiet = TRUE)\ndata <- expand.ev(amt = 10, ii = 24, addl = 11, ID = 1:6)\ntimes <- tgrid(start = 0, end = 480, delta = .1)\n\nout <- mrgsim_d(mod, data = data, tgrid = times)\nplot(out)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n\n## Resources\n\n- The [mrgsolve user guide](https://mrgsolve.org/user-guide/) is probably not the place you want to start, because it very quickly dives in deep and talks about the domain specific language used to specify models, but once you've wrapped your head around the basics that's the place to look for details.\n\n- The [mrgsolve vignettes](https://mrgsolve.org/vignettes/) provide a nice place to start, but one thing you need to keep in mind is that the vignettes posted at [mrgsolve.org/vignettes](https://mrgsolve.org/vignettes/) are not identical to the vignettes that appear on the pkgdown website (i.e., [mrgsolve.org/docs/articles](https://mrgsolve.org/docs/articles/)), so it's worth being careful to check which one you're looking at!\n\n- Speaking of which, the [mrgsolve pkgdown site](https://mrgsolve.org/docs/) provides all the usual documentation that you'd expect of an R package in the usual format. Function reference guides, some vignettes, links to github, etc., all that is there.\n\n- The [learn mrgsolve](https://mrgsolve.org/learn.html) page on the mrgsolve website has links to presentations, courses, and other things that can be helpful in getting started.\n\n- Finally, there's a [blog](https://mrgsolve.org/blog/) associated with the package that has a variety of tips, tricks, updates and news. \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}