{
  "hash": "42a13c0883f6b18ac96badb9ea9abe83",
  "result": {
    "markdown": "---\ntitle: \"mrgsolve\"\ndescription: \"This is a subtitle\"\ndate: \"2023-08-10\"\n--- \n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mrgsolve, warn.conflicts = FALSE)\n```\n:::\n\n\n- Working from this vignette: https://mrgsolve.org/vignettes/01-get-started.html\n- mrgsolve wraps the public domain fortran library ODEPACK\n- the R package uses S4 for functional OOP\n\n## Building a model\n\n### Using `modlib()`\n\nThe mrgsolve has a set of predefined pharmacokinetic models that you can work with when getting started. They're stored in a package library whose location is accessible by calling `modlib()` with no arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models\"\n```\n:::\n:::\n\n\nTo see the names of the models:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodlib(list = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nmrgsolve internal library:\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n  effect  tmdd  viral1  viral2  emax  irm1  irm2  irm3  irm4  pk1cmt  pk2cmt  pk3cmt  pk1  pk2  pk2iv  popex  pred1  pbpk  1005  nm-like\n```\n:::\n:::\n\n\nTo load one of these models:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- modlib(\"pk1\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBuilding pk1 ... done.\n```\n:::\n:::\n\n\nThe first time you call this it compiles the model, which doesn't take very long but nevertheless the package is smart enough to cache compiled models, so if you call it again it'll just load the cached version.\n\n### Using `mread()`\n\nWhen I first started using mrgsolve I used the `modlib()` function quite a bit just so that I could dive into running simulations without having to think much about what's going on internally, but now that I've gotten more of a sense of it this isn't my preferred workflow. I'm always a bit uncomfortable with functions that return quite dramatically different output based on the parameters you pass. They're harder to program with. So instead, here's how I would now think about the same commands. First, the models that come bundled with mrgsolve are stored as package files, so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_path <- fs::path_package(\"mrgsolve\", \"models\")\nmodel_path\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n/home/danielle/R/x86_64-pc-linux-gnu-library/4.3/mrgsolve/models\n```\n:::\n:::\n\n\nTo get file paths to all the model files in this folder, I could do something like `fs::dir_ls(model_path)`. The TL;DR though is that the file name for the \"pk1\" model that I built in the previous section is `pk1.cpp`, and the other models that come bundled with mrgsolve are named similarly. \n\nUsing the built-in models strikes me as something of an unusual case where the model code is stored outside the R project from which you're invoking it, and I suppose the `modlib()` function is written to provide users with an easy way to access that model code. A more general purpose (and, happily, more type stable) workflow is provided by the `mread()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- mread(model = \"pk1\", project = model_path)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBuilding pk1 ... (waiting) ...\ndone.\n```\n:::\n:::\n\n\nOptionally you can explicitly provide the file name for the model (within the `project` folder), but in this case we don't need to: if the `file` argument is not specified `mread()` assumes by default that the file name is the same as the `model` name with file extension `.cpp`. \n\n## Model objects\n\nWhat precisely have we just constructed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"mrgmod\"\nattr(,\"package\")\n[1] \"mrgsolve\"\n```\n:::\n:::\n\n\nThe mrgsolve package is build using S4 classes, so we can use `print()` or `show()` to get a summary of the object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n-----------------  source: pk1.cpp  -----------------\n\n  project: /home/danielle/R...gsolve/models\n  shared object: pk1-so-2b2023329d66 \n\n  time:          start: 0 end: 24 delta: 1\n                 add: <none>\n\n  compartments:  EV CENT [2]\n  parameters:    CL V KA [3]\n  captures:      CP [1]\n  omega:         0x0 \n  sigma:         0x0 \n\n  solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n------------------------------------------------------\n```\n:::\n:::\n\n\nPerhaps more usefully, there is also a `see()` function we call to inspect the source code of the model file:^[If you want to be a jerk you can pull the same information from the object attributes using `attr(mod, \"code\")`, but if you bypass the API provided by the developer like that, it's \"off-label\" usage and there's absolutely no guarantee that it will work in the future.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsee(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nModel file:  pk1.cpp \n$PARAM @annotated\nCL   :  1 : Clearance (volume/time)\nV    : 20 : Central volume (volume)\nKA   :  1 : Absorption rate constant (1/time)\n\n$CMT  @annotated\nEV   : Extravascular compartment\nCENT : Central compartment\n\n$GLOBAL\n#define CP (CENT/V)\n\n$PKMODEL ncmt = 1, depot = TRUE\n\n$CAPTURE @annotated\nCP : Plasma concentration (mass/volume)\n```\n:::\n:::\n\n\nParameters can be extracted using `param()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n Model parameters (N=3):\n name value . name value\n CL   1     | V    20   \n KA   1     | .    .    \n```\n:::\n:::\n\n\nWhat actually happens here is that it returns a \"parameter_list\" object, and the output looks nice and pretty because it has a print method. But internally it's basically just a list (...sort of, not exactly), and it has a define `$` operator, so you can extract the clearance parameter as `param()$CL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparam()$CL\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n## Event objects\n\nModel objects represent the underlying ODE system. They don't store information about \"interventions\" (external forcers) on the system. In the pharmacokinetic context the main intervention we're thinking about is dosing. An events object returned by `ev()` returns a event schedule that would be familiar to NONMEM users^[I really need to *learn* NONMEM. It's becoming a bit absurd that I'm learning everything else before NONMEM. Oh well, I was never someone to do things in the proper order.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevents <- ev(amt = 100, ii = 24, addl = 9)\nevents\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEvents:\n  time amt ii addl cmt evid\n1    0 100 24    9   1    1\n```\n:::\n:::\n\n\nThe arguments are consistent with NONMEM standard names:\n\n- `amt` is the amount of drug\n- `ii` is the interdose interval\n- `addl` is number of additional doses\n\nA tiny bit of care is needed here. The `events` object looks like a data frame, and it has a defined `$` operator that behaves as you'd expect if it were a data frame, but this errors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevents[1, ]\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in events[1, ]: object of type 'S4' is not subsettable\n```\n:::\n:::\n\n\nAgain this is an S4 class and there is in fact a data frame stored internally^[Yes, I'm a jerk: you can find it with `attr(events, \"data\")`], but if you want to coerce it explicitly to a data frame or a tibble you'll need to convert it explicitly. For instance, this...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble::as_tibble(events)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 6\n   time   amt    ii  addl   cmt  evid\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     0   100    24     9     1     1\n```\n:::\n:::\n\n\n...is in fact a tibble. \n\n<!--\n\n# simulations -------------------------------------------------------------\n\n# okay, the example in the vignette shows a workflow using pipes...\npk1_mod |> ev(evnt) |> mrgsim(end = 480, delta = 0.1)\n\n\n# ... but weirdly I find it unhelpful, so let's run the same analysis with a \n# single call to mrgsim(). this is equivalent:\npk1_out <- mrgsim(\n  x = pk1_mod,\n  events = evnt,\n  end = 480,\n  delta = 0.1\n)\npk1_out # this is an \"mrgsims\" object, coercible to data frame\n\n# ... or a tibble\ntibble::as_tibble(pk1_out)\n\n# there's some difficulty following the vignette here because end and delta \n# aren't named arguments to mrgsim(), they're passed via the dots to update().\n# what's actually happening here is that the explicitly specified values for\n# end and delta are used to override the default times (in pk1_mod???) that\n# simulations are run for. You can access these using stime()\nstime(pk1_mod)\n\n# and if we run the simulation *without* setting end and delta in mrgsim()\n# these are the timepoints returned:\nmrgsim(pk1_mod, events = evnt)\n\n\n# ... anyway, mrgsim objects have a default plot method:\nplot(pk1_out)\n\n# the plot uses lattice graphics so you can capture and modify it should you\n# really want to:\nx <- plot(pk1_out)\nclass(x)\n\n# but honestly if I wanted to customise I'd probably just switch to \n# ggplot2. it's very little work to do the conversion and from there\n# you have access to the full ggplot2 ecosystem...\ndat <- pk1_out |> \n  tibble::as.tibble() |>\n  tidyr::pivot_longer(\n    cols = c(EV, CENT, CP), \n    names_to = \"variable\", \n    values_to = \"value\"\n  )\n\nlibrary(ggplot2)\nggplot(dat, aes(time, value)) + \n  geom_line() + \n  facet_wrap(~ variable, scales = \"free_y\")\n\n-->\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}