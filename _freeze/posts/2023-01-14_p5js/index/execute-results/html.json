{
  "hash": "7d72b9016988d6fa302479c96479ca2d",
  "result": {
    "markdown": "---\ntitle: \"Fun and games with p5.js and observable.js in quarto\"\ndescription: \"Okay it's a short post in which I teach myself a bit of p5.js, but it does have five different donut examples which seems cool?\"\ndate: \"2023-01-14\"\ncategories: [Art, P5, Observable, Javascript, Quarto]\nimage: donut.jpg\n---\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\n> Be sweet to me, baby <br>\nI wanna believe in you <br>\nI wanna believe <br>\nBe sweet <br>\nBe sweet to me, baby <br>\nI wanna believe in you <br>\nI wanna believe in something <br>\n&nbsp; -- Japanese Breakfast\n\nOkay, so... I write this blog using [quarto](https://quarto.org/), and quarto has native support for [observable.js](https://observablehq.com)\n... and observable.js supports third-party javascript libraries such as [p5.js](https://p5js.org/) executing in code cells... so, like... I can use p5.js to create generative art, inside the browser, inside a blog post? Right?\n\nApparently the answer to that is yes. \n\nThere is but one tiny problem. I don't know anything about observable.js or p5.js. I supposed I'd best remedy that.\n\n## Enabling p5js\n\nThe first step in the process is enabling p5.js, which is not one of the core libraries in observable, and is not immediately available. To use a third-party library that exists as an [NPM modules](https://docs.npmjs.com/about-packages-and-modules) we can import it using `require()`.\n\n\n```{ojs}\n//| output: all\nP5 = require(\"p5\")\n```\n\n\nJust like that, thanks to the joy of the [jsDelivr CDN](https://www.jsdelivr.com/), p5.js is now available to me in this post.\n\nWell, sort of. As you can see from the output,^[An assignment like this would not normally produce any visible output for an observable.js code cell within in a quarto document, but I've set `output: all` for expository purposes.] the `P5` object is a function that takes three inputs. To do anything useful with it, I'll use a trick I learned from [this fabulous notebook by Tom MacWright](https://observablehq.com/@tmcw/p5) to run p5.js in \"instance mode\". Normally, p5.js works by defining a lot of global objects. That works fine if you're only doing one \"sketch\" on a single page, but it's not so clean if you want to write modular code where a single page (like this one) could contain multiple p5.js sketches.  \n\nTo run p5.js in instance mode, and in a way that plays nicely with observable.js and quarto, I'll define  `createSketch` as a [generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*):\n\n\n```{ojs}\nfunction* createSketch(sketch) {\n  const element = DOM.element('div');\n  yield element;\n  const instance = new P5(sketch, element, true);\n  try {\n    while (true) {\n      yield element;\n    }\n  } finally {\n    instance.remove();\n  }\n}\n```\n\n\nUsing this approach, each instantiation of `P5` is attached to a div element that created when `createSketch` is called. If you want to know more about how this approach works, it's probably best to go to the original source that I adapted it from, because Tom has commented it and explained it nicely: [observablehq.com/@tmcw/p5](https://observablehq.com/@tmcw/p5)\n\n## Donut 1\n\nIn keeping with the tradition I've set up in the last few blog posts, all the examples are donut themed.^[A tradition that, like most things, will last only until I get bored with it.] When calling `createSketch` I'll pass an anonymous function that takes a single argument `s`, the document element to which all the p5 functions are attached. I'll use the [arrow notation](https://www.w3schools.com/js/js_arrow_function.asp), so my code is going to look something like this:\n\n\n```{ojs}\n//| eval: false\ncreateSketch(s => {\n  // add some p5.js code \n})\n```\n\n\nThe idea in p5.js is all the work is done by two functions. The `setup` function includes code that is called only once, and if you want to draw static images you can do everything at the setup stage. In contrast the `draw` function is called repeatedly, so you can use that to add dynamic elements. \n\nHere's an example of a static sketch that draws a single donut shape using two circles:\n\n\n```{ojs}\ncreateSketch(s => {\n    s.setup = function() {\n      s.createCanvas(500, 500);\n      s.background(\"black\");\n      s.fill(\"red\").circle(250, 250, 100);\n      s.fill(\"black\").circle(250, 250, 30);\n    };\n  }\n)\n```\n\n\nIn this example: \n\n- `createCanvas` creates the drawing area in which the sketch will be rendered. Arguments are the width and height in pixels \n- `background` sets the background colour. The colour specification is flexible: it can be a recognised colour name, a hex string, or a numeric RGB specification\n- `fill` sets the fill colour\n- `circle` draws a circle: the first two arguments specify the origin of the circle, and the third argument specifies the diameter\n\nI've used [method chaining](https://dev.to/isiakaabd/method-chaining-in-javascript-154a) here to remind me that the first `fill` and the first `circle` go together: writing `s.fill(\"red\").circle(250, 250, 100)` on a single line helps me group code together conceptually. It's mostly for my own convenience though.\n\n## Donut 2\n\nOkay Danielle, that's nice but it's not *that* nice. Can we do something a little more interesting? Maybe with some dynamics? Well okay, Other Danielle, since you asked so sweetly, here's an example with a moving circle that changes colour and traces out a donut shape:\n\n\n```{ojs}\ncreateSketch(s => {\n  \n    s.setup = function() {\n      s.createCanvas(500, 500);\n      s.background(0);\n      s.noStroke();\n    };\n    \n    s.draw = function() {\n      s.translate(\n        100 * s.cos(s.millis() * .001 * s.PI),\n        100 * s.sin(s.millis() * .001 * s.PI),\n      );\n      if (s.random(0, 1) < .1) {\n        s.fill(s.random(0, 255));\n      }\n      s.circle(250, 250, 100);\n    };\n    \n  }\n)\n```\n\n\nThis example makes use of some geometry functions included in p5.j (`sin`, `cos`, `translate`), a random number generator (`random`), and timer that returns the number of milliseconds since the sketch started (`millis`). These are all documented in the [p5.js reference](https://p5js.org/reference/). \n\n\n## Donut 3\n\nFor the third example we'll introduce some fonts, adapting an example from [observablehq.com/@tmcw/p5](https://observablehq.com/@tmcw/p5). First, I'll add some CSS to import the Courgette font:\n\n\n::: {.cell}\n\n```{.css .cell-code}\n@import url(https://fonts.googleapis.com/css?family=Courgette);\n```\n\n\n<style type=\"text/css\">\n@import url(https://fonts.googleapis.com/css?family=Courgette);\n</style>\n:::\n\n\nNow we can use that font in a p5.js scrolling window:\n\n\n```{ojs}\ncreateSketch(s => {\n  \n    s.setup = function() {\n      s.createCanvas(746, 300);\n      s.textFont('Courgette');\n      s.textStyle(s.BOLD);\n      s.textAlign(s.CENTER, s.CENTER)\n    };\n    \n    s.draw = function() {\n      s.translate(\n        s.millis() * (-0.1) % (s.width + 1000), \n        s.height / 2\n      );\n      s.background('#222222');\n      s.fill('#DC3F74').textSize(100);\n      s.text('Donuts: A Hole World', s.width + 500, 0);\n    };\n    \n  }\n)\n```\n\n\nCould life be any more thrilling than this?\n\n\n## Donut 4\n\nWell, maybe it can. We could make it a little more interesting by using webGL to move our donut plots into the... THIRD DIMENSION! (Gasp!)\n\n\n\n```{ojs}\ncreateSketch(s => {\n\n  s.setup = function() {\n    s.createCanvas(746, 746, s.WEBGL);\n    s.noStroke();\n  }\n\n  s.draw = function() {\n\n    s.background(0);\n\n    let locX = s.mouseX - s.height / 2;\n    let locY = s.mouseY - s.width / 2;  \n    \n    s.ambientLight(60, 60, 60);\n    s.pointLight(190, 80, 190, locX, locY, 100);\n    s.pointLight(80, 80, 190, 0, 0, 100);\n  \n    s.specularMaterial(255);\n    s.rotateX(s.frameCount * 0.01);\n    s.rotateY(s.frameCount * 0.01);\n    s.torus(150, 80, 64, 64);\n  }\n\n})\n```\n\n\nIf you move the mouse over the donut^[I can't make up my mind if the colour scheme implies this is a bisexual donut or a trans donut. Oh wait, it's probably both.] you'll see that the light source moves with it.\n\n\n## Donut 5\n\nFor the final example, I'll do a tiny bit of object-oriented programming. Inspired by a generative art course by Bernat Ferragut ([ga-course.surge.sh](https://ga-course.surge.sh/)) that I was skimming yesterday, I'll define a `Dot` class that creates a particle that moves around on the canvas and has the ability to bounce off circular boundaries:\n\n\n\n```{ojs}\nclass Dot {\n  constructor(sketch, x, y, colour, size) {\n    this.s = sketch;\n    this.x = x | 0;\n    this.y = y | 0;\n    this.colour = colour;\n    this.size = size;\n    this.velX = this.s.random(-2, 2);\n    this.velY = this.s.random(-2, 2);\n  }\n\n  on() {\n    this.s.noStroke();\n    this.s.fill(this.colour);\n    this.s.circle(this.x, this.y, this.size);\n  }\n\n  move() {\n    this.x += this.velX;\n    this.y += this.velY;\n  }\n  \n  bounce(radius, inside) {\n    let x = this.x - this.s.width/2;\n    let y = this.y - this.s.height/2;\n    if (\n      inside && x*x + y*y > radius * radius ||\n      !inside && x*x + y*y < radius * radius\n    ) {\n    \n      // https://math.stackexchange.com/a/611836\n      let nx = x / this.s.sqrt(x*x + y*y);\n      let ny = y / this.s.sqrt(x*x + y*y);\n      let vx = this.velX;\n      let vy = this.velY;\n      this.velX = (ny*ny - nx*nx)*vx - 2*nx*ny*vy;\n      this.velY = (nx*nx - ny*ny)*vy - 2*nx*ny*vx;\n    \n    }\n  }\n  \n}\n```\n\n\n\nNaturally, I will use this to draw a donut:\n\n\n```{ojs}\ncreateSketch(s => {\n\n  let n = 100;\n  let dot;\n  let dotList = [];\n  let palette = [\n    s.color(\"#6B1B00\"),\n    s.color(\"#AE8B70\"),\n    s.color(\"#F9FEFB\"),\n    s.color(\"#56382D\") \n  ];\n\n  s.setup = function() {\n    s.createCanvas(746, 746);\n    for(let i = 0; i < n; i++) {\n      let angle = s.random(0, s.TWO_PI);\n      let radius = s.width * s.random(.12, .33);\n      dotList.push(dot = new Dot(\n        s,\n        s.width/2 + s.cos(angle) * radius,\n        s.height/2 + s.sin(angle) * radius,\n        s.random(palette),\n        s.random(1, 5)\n      ));\n    }\n  };\n    \n  s.draw = function() {\n    dotList.map(dot => {\n      dot.on();\n      dot.move();\n      dot.bounce(s.width * .35, true);\n      dot.bounce(s.width * .1, false);\n    });\n  };\n})\n\n```\n\n\nMmmm.... donuts.\n\n\n<!--------------- appendices go here ----------------->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}