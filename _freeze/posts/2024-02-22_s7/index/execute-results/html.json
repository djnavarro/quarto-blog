{
  "hash": "0704c3b13258800f16e782342841dd0c",
  "result": {
    "markdown": "---\ntitle: \"Creating new generative art tool in R with grid, ambient, and S7\"\ndescription: \"There might be a darker undercurrent in this one\"\ndate: \"2024-02-22\"\ncategories: [\"R\", \"Object-Oriented Programming\", \"Grid Graphics\", \"Art\"]\n--- \n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nThe Sydney Gay and Lesbian Mardi Gras is in full swing, a multi-week festival and parade sprawling across multiple sites across the city. As I write this I am sitting in the sunshine at a bar on Bondi Beach, while a massive stage is being constructed below for the \"Bondi Beach Party\" event. As always, the surfers, swimmers, sunbathers and assorted Swifties in town for the Eras Tour are having a lovely day at the beach. Everyone is partying.\n\nAbout a kilometer away, above the iconic limestone cliffs that surround almost every Sydney beach, is the Marks Park Memorial in Tamarama. The memorial serves as a remembrance for the LGBT victims of hate crimes in Sydney, a stark reminder of the perennial apathy that the NSW police show towards these crimes, and most especially to the gay men who were murdered at these cliffs back in the 1970s and 1980s and whose deaths are to this day the subject of inquests into the appalling behaviour of the police in this city.\n\nThe contrast is stark. It is one that few people are willing to face up to, particularly cisgender straight people who fancy themselves to be allies of our community but think that allyship means nothing more than waving a little rainbow flag and mindlessly reciting slogans like \"Love Is Love\" or \"Trans Rights Are Human Rights\". Barely a week ago a man told me to my face that things have changed. It's different now. Everyone is so accepting. You don't need to hide who you are. Et cetera.\n\nNone of this is true, of course. I could tell the very recent story of Nex, the non-binary teenager whose death the Oklahoma authorities seem to be trying very hard not to investigate. I could tell the story of Brianna Ghey, a murdered trans girl stabbed 27 times in the UK. Closer to home, I could tell the story of Mhelody Bruno, a Filipina trans woman strangled to death by her boyfriend and whose death was barely even investigated by the NSW police and courts. \n\nI could tell all these stories, but they would have very little impact on the straight men who tell me that actually things are *fine* now. These are outliers, you see. The exceptions. Not the norm. \n\nAgain, it is not true. Consider for example, the case of Danielle Navarro, a bisexual trans woman who is about as privileged as you could possibly be given those other categories. Barely a week ago a man expressed disbelief to me that such a person could have *possibly* had bad experiences. \n\nAnd so we come to this post. Like everything on this blog it is in fact a data science post. I'm going to talk about art, about object oriented programming in R, about the grid graphics system, and I'll do it all with a lovely LGBT flavoured palette in honour of Mardi Gras.\n\nBut make no mistake. This is not a celebratory \"partying on the beach\" kind of post. There will be art, but there will also be trauma.\n\nConsider yourselves warned.\n\n## Prelude\n\nThe rainbow pride palette is surprisingly amenable to artistic exploration,  unlike the trans pride palette which I have almost never had any success working with artistically. Here, for example, is a very simple piece of generative art -- and the code that generates it -- that I made a few days ago.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# colour scheme\npalette <- c(\n  \"#e50000\", \"#ff8d00\", \"#ffee00\", \n  \"#028121\", \"#004cff\", \"#770088\"\n)\n\n# parameters defining objects\nvalues <- tibble::tibble(\n  x = cos(seq(0, pi * 5/3, length.out = 6)),\n  y = sin(seq(0, pi * 5/3, length.out = 6)),\n  n = 500L,\n  fill = palette,\n  color = fill\n)\n\n# list of blob objects to add to a sketch\nblobs <- purrr::pmap(values, blob)\n\n# define and draw a sketch containing the objects\nblobs |> sketch() |> draw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThe piece is very simple, but has a lovely balance to my eye. Each colour of the pride flag is captured in a single \"blob\", with the blobs arranged in a circular overlapping pattern that conveys a sense of movement and progress. More subtly, if you look at the blobs closely you can detect a kind of spatial autocorrelation. Notice how the green, yellow, and orange blobs all have a protrusion on their right hand side at approximately the same place. You'd be tempted to think this is coincidental, but it isn't. Hidden under the hood there is a vector field that induces correlations on the random process that creates the blob shapes. This is by design.\n\nThe spatial autocorrelation that provides hidden structure to this artwork becomes a little more obvious if I switch to a different piece constructed with very similar tools:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# parameters defining objects\nvalues <- tibble::tibble(\n  x = rnorm(200L, sd = 1.5),\n  y = rnorm(200L, sd = 1.5),\n  xend = x,\n  yend = y + 1,\n  width = 1,\n  n = 500L,\n  fill = sample(palette, 200L, replace = TRUE),\n  color = fill\n)\n\n# list of ribbon objects to add to a sketch\nribbons <- purrr::pmap(values, ribbon)\n\n# define and draw a sketch containing the objects\nribbons |> \n  sketch() |> \n  draw(xlim = c(-2, 2), ylim = c(-2, 2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nIn this piece the blobs are more ribbon shaped, and the piece as a whole feels a little like a rainbow coloured lava lamp. The spatial autocorrelation is more obvious. The ribbons tend to be thin in the same regions of the plot, and thin in the same regions. \n\nEach of these ribbons is a distinct individual object, yet somehow they all have similar experiences when embedded in the environment that defines the art. There is a *pattern* to how they flow through this world.^[Look, I know I'm hitting the reader over the head with the metaphor, but I'm not trying to be subtle here. I've met quite a lot of straight people over the years and I've learned from experience that you really can't be subtle with them when talking about this stuff.]\n\nAn artist looking at this piece might wonder about the trickery used to create this structure. An R programmer looking at it, however, might be wondering something very different. They would likely be asking questions like \"what the fuck is this `ribbon()` function, and what the hell is a `sketch()`, and how are you rendering this with this `draw()` function that you piped it to? Absolutely none of this is part of base R, it's clearly not ggplot2 code, and it's not even consistent with *any* well-known data visualisation tool in the R ecosystem. What the hell are you doing here girl?\n\n\n\n## Act I: Learning to love S7\n\n> I walk past the bar in my neighbourhood. It has pride flags plastered on the window. They're advertising a drag show. My hands start shaking, remembering the feel of the older man's hands wrapped tightly around my throat as he forced his tongue down my throat at the queer themed rainbow bar upstairs and demanded that I fuck him. He was so strong. I froze. I wonder what his name was. It's not like he bothered to tell me that.\n\nThis whole thing started because I wanted to learn how to use the relatively new [S7 object oriented programming system](https://rconsortium.github.io/S7/) that is intended to serve as a successor to the informal-but-janky [S3](https://adv-r.hadley.nz/s3.html) system and the formal-but-painful [S4](https://adv-r.hadley.nz/s4.html) system that already exist within R.^[For folks outside of the R community: S3, S4, and S7 are all considered to be \"functional\" OOP systems, and they are broadly similar to function overloading in C++ and, I have recently learned, is also analogous to how methods are defined in Julia for functions of the same name but with different signatures. The functional style of OOP programming is one in which methods attach to generic functions (or to function names), as opposed to more traditional \"encapsulated\" OOP systems in which methods attach to objects. The encapsulated style is standard in Python, for example, and also appears in R via the [R6](https://adv-r.hadley.nz/r6.html) OOP system that I have used in other blog posts (e.g., [here](https://blog.djnavarro.net/posts/2022-12-22_queue/) and [here](https://blog.djnavarro.net/posts/2023-12-27_seedcatcher/)). I mention these tiresome details because I have learned to my detriment that if I don't exhaustively list the various distinctions between OOP systems and how R adopts multiple styles, I *will* have to deal with tiresome people mansplaining to me how R is bad at OOP and how OOP in R is wrong and isn't *really* OOP and honestly I'm asleep before I finish reading the complaint.] It seemed like a very simple exercise when I started, but as with any exercise in learning a new thing I very quickly felt like a dog trying to understand Norway.^[A *Slow Horses* reference, in case you missed it.] \n\nAs is my habit, I've taken my learning process and used it to create art. What I want to do with S7 here is create a system for programmatically constructing \"drawable shapes\" that abide by particular rules, alongside a toolkit that can take these objects and render them within an abstract \"sketch\" that can later be rendered to an image with the help of the grid graphics system. In that sense, the basic idea underpinning my tool is not that different -- though far less sophisticated -- to how ggplot2 works, but I've designed it with different considerations in mind. My tools are not designed for data visualisation, they are designed for generative art. Spiritually they have more in common with p5.js than ggplot2.\n\n### Writing a new S7 class\n\nOkay look. It's kind of like this. While eventually the plan is for S7 to become part of base R, right now it's a package so we'll have to load the package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\n```\n:::\n\n\nLet's say I want to define a class that represents a circle. I can do that using the `new_class()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\", \n  properties = list(\n    x = class_numeric,\n    y = class_numeric,\n    radius = class_numeric\n  )\n)\n```\n:::\n\n\nBy doing so, I create a new function called `circle()` that I can call to create a new circle object. In the code below I create an object `cc` that -- at least in some abstract sense of the term -- corresponds to the unit circle:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- circle(x = 0, y = 0, radius = 1)\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ x     : num 0\n @ y     : num 0\n @ radius: num 1\n```\n:::\n:::\n\n\nHere we have a circle object that has three \"properties\" `x`, `y`, and `radius`. We can think of it as something broadly similar to a named list, but it has rules attached. In the class definition above I specified that `x`, `y`, and `radius` must be numeric values: they are allowed to be integers or doubles, but they can't be characters. Here's what happens if I try to create a circle with `radius = \"big\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle(x = 0, y = 0, radius = \"big\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <circle> object properties are invalid:\n- @radius must be <integer> or <double>, not <character>\n```\n:::\n:::\n\n\nSo here we see something that we wouldn't normally have in, say, an S3 class:^[Or at least not without a lot of extra effort on the developer side.] the class definition explicitly says that the `radius` property must be numeric, so my `circle()` function throws an error if I foolishly try to pass it a non-numeric radius.\n\nOkay so what's going on with these \"properties\"? Properties are analogous to \"slots\" in an S4 object^[In contrast S3 is so chaotically informal that it doesn't have any real notion of an \"accessor\" operator. Some S3 classes are atomic objects internally (e.g., a Date is simply a double with some attributes) and have no accessor operator, whereas others are lists internally and as such use `$` as the accessor.] and can be accessed using `@`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc@radius\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nOne nice thing about S7 is that you can modify (most) properties of an object directly. So if I want to update my `cc` object so that it now (nominally) represents a circle with radius 2, I can do this:^[Like S3 and S4 and like the vast majority of R objects, S7 objects have copy-on-modify semantics. This is distinct to environments and R6 classes which have reference semantics. But let's be honest, shall we? You either (a) already know this, (b) don't care, or (c) don't find this telegraphic explanation very helpful because it really isn't very helpful. My aims in this post are pretty limited so really if you want to wrap your head around this stuff a better bet is to read [Advanced R](https://adv-r.hadley.nz/).]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc@radius <- 2\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ x     : num 0\n @ y     : num 0\n @ radius: num 2\n```\n:::\n:::\n\n\nAmazing. Thrilling. The excitement, it cannot be contained.\n\n### Adding default values\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\", \n  properties = list(\n    x = new_property(class = class_numeric, default = 0),\n    y = new_property(class = class_numeric, default = 0),\n    radius = new_property(class = class_numeric, default = 1)\n  )\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle(x = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ x     : num 2\n @ y     : num 0\n @ radius: num 1\n```\n:::\n:::\n\n\n\n### Computed properties\n\nLet's be honest. This circle class only represents a circle in the most abstract sense. It's a list of three numbers that you need to describe a circle, but it doesn't actually compute any points that lie on the circumference of said circle. If you wanted to *draw* the circle in question, you'd have to actually compute those points yourself. We can improve on this situation. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\", \n  properties = list(\n    x = new_property(class_numeric, default = 0),\n    y = new_property(class_numeric, default = 0),\n    radius = new_property(class_numeric, default = 1),\n    n = new_property(class_integer, default = 100L),\n    points = new_property(\n      class = class_data.frame,\n      getter = function(self) {\n        angle <- seq(0, 2 * pi, length.out = self@n)\n        data.frame(\n          x = self@x + self@radius * cos(angle),\n          y = self@y + self@radius * sin(angle)\n        )\n      } \n    )    \n  )\n)\n```\n:::\n\n\nWhen I create a new circle, the `points` property is automatically computed using the user-specified `x`, `y`, `radius`, and `n` properties:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- circle(x = 1, y = 2, radius = 3, n = 50L)\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ x     : num 1\n @ y     : num 2\n @ radius: num 3\n @ n     : int 50\n @ points:'data.frame':\t50 obs. of  2 variables:\n .. $ x: num  4 3.98 3.9 3.78 3.61 ...\n .. $ y: num  2 2.38 2.76 3.13 3.47 ...\n```\n:::\n:::\n\n\nWhen I update one of the other properties, the computed `points` property is automatically updated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc@n <- 5L\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ x     : num 1\n @ y     : num 2\n @ radius: num 3\n @ n     : int 5\n @ points:'data.frame':\t5 obs. of  2 variables:\n .. $ x: num  4 1 -2 1 4\n .. $ y: num  2 5 2 -1 2\n```\n:::\n:::\n\n\nNotice, however, that because I defined a \"getter\" function for `points` and (deliberately) chose not to define a `setter` fuction, this computed property is read-only. You cannot directly modify `points`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc@points <- data.frame(x = 1:3, y = 4:6)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: Can't set read-only property <circle>@points\n```\n:::\n:::\n\n\nFor the purposes of the tool I want to create this is a desirable feature. I *don't* want users trying to manually create the `points` that lie on the circumference of a circle. The abstract concept of a circle is defined by `x`, `y` and `radius`, and if I want to create `n` evenly spaced points on the circle, then these points are automatically computed as a byproduct of specifying these values. \n\n### Validators\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\", \n  properties = list(\n    x = new_property(class_numeric, default = 0),\n    y = new_property(class_numeric, default = 0),\n    radius = new_property(class_numeric, default = 1),\n    n = new_property(class_integer, default = 100L),\n    points = new_property(\n      class = class_data.frame,\n      getter = function(self) {\n        angle <- seq(0, 2 * pi, length.out = self@n)\n        data.frame(\n          x = self@x + self@radius * cos(angle),\n          y = self@y + self@radius * sin(angle)\n        )\n      } \n    )    \n  ),\n  validator = function(self) {\n    if (length(self@x) != 1) return(\"x must be length 1\")\n    if (length(self@y) != 1) return(\"y must be length 1\")\n    if (length(self@radius) != 1) return(\"radius must be length 1\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (self@radius < 0) return(\"radius must be a non-negative number\")\n    if (self@n < 1L) return(\"n must be a positive integer\")\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle(radius = -0.234)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <circle> object is invalid:\n- radius must be a non-negative number\n```\n:::\n:::\n\n\n### Building structure\n\nTo start transforming this into something a little more realistic, we will need to create a richer collection of classes. For instance, in the code above I stored the computed `points` as a simple data frame. It would be more sensible to define an actual S7 class for this, with its own validator to make sure that any shape classes I define compute a valid set of points:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints <- new_class(\n  name = \"points\",\n  properties = list(\n    x = class_numeric,\n    y = class_numeric\n  ),\n  validator = function(self) {\n    if (length(self@x) != length(self@y)) {\n      \"x and y must be the same length\"\n    }\n  }\n)\n```\n:::\n\n\nSimilarly, when the time comes to start drawing these things, my circles (and other shapes) will need to have a defined `style`. Again, I can create a class for this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstyle <- new_class(\n  name = \"style\",\n  properties = list(\n    color     = new_property(class_character, default = \"black\"),\n    fill      = new_property(class_character, default = \"black\"),\n    linewidth = new_property(class_numeric, default = 1)\n  )\n)\n```\n:::\n\n\nYou'll notice that `style` currently doesn't have a validator. It probably should, but I haven't yet thought carefully about what constraints I *want* to impose on `style` objects, so right now this is a bit freeform. \n\nLater on, I'm going to define several different kinds of drawable shapes, and they'll have some structural similarities that I want to enforce. To that end I'll create an class called `drawable`:^[Ideally I'd like to make this an abstract class, in which users can't directly create a new `drawable`. In principle this is achievable by setting `abstract = TRUE` in the call to `new_class()`, but what I've found so far is that creates problems when -- as happens slightly later in the post -- I define a custom constructor function for my \"circle-subclassing-drawable\" class. I imagine this will be dealt with at some point, but for now I'm just ignoring the idea of abstract classes.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrawable <- new_class(\n  name = \"drawable\",\n  properties = list(\n    style = new_property(\n      class = style,\n      default = style()\n    ),\n    points = new_property(\n      class = points,\n      getter = function(self) points(x = numeric(0L), y = numeric(0L))\n    )\n  )\n)\n```\n:::\n\n\nOkay, so now we can define `circle` as a subclass of `drawable`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\",\n  parent = drawable,\n  properties = list(\n    x = new_property(class_numeric, default = 0),\n    y = new_property(class_numeric, default = 0),\n    radius = new_property(class_numeric, default = 1),\n    n = new_property(class_integer, default = 100L),\n    points = new_property(\n      class = points,\n      getter = function(self) {\n        angle <- seq(0, 2 * pi, length.out = self@n)\n        points(\n          x = self@x + self@radius * cos(angle),\n          y = self@y + self@radius * sin(angle)\n        )\n      }\n    )\n  ),\n  validator = function(self) {\n    if (length(self@x) != 1) return(\"x must be length 1\")\n    if (length(self@y) != 1) return(\"y must be length 1\")\n    if (length(self@radius) != 1) return(\"radius must be length 1\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (self@radius < 0) return(\"radius must be a non-negative number\")\n    if (self@n < 1L) return(\"n must be a positive integer\")\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- circle()\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ style : <style>\n .. @ color    : chr \"black\"\n .. @ fill     : chr \"black\"\n .. @ linewidth: num 1\n @ points: <points>\n .. @ x: num [1:100] 1 0.998 0.992 0.982 0.968 ...\n .. @ y: num [1:100] 0 0.0634 0.1266 0.1893 0.2511 ...\n @ x     : num 0\n @ y     : num 0\n @ radius: num 1\n @ n     : int 100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(cc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"circle\"    \"drawable\"  \"S7_object\"\n```\n:::\n:::\n\n\nNotice though, that this is cumbersome: if you want to override the default style you have to create a circle like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle(style = style(color = \"red\"), radius = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ style : <style>\n .. @ color    : chr \"red\"\n .. @ fill     : chr \"black\"\n .. @ linewidth: num 1\n @ points: <points>\n .. @ x: num [1:100] 2 2 1.98 1.96 1.94 ...\n .. @ y: num [1:100] 0 0.127 0.253 0.379 0.502 ...\n @ x     : num 0\n @ y     : num 0\n @ radius: num 2\n @ n     : int 100\n```\n:::\n:::\n\n\nThe reason this is cumbersome is that I have created a structure where all drawables necessarily contain a user-customisable `style` object and a read-only `points` object. This is a deliberate design choice because I want the ability to easily extract these two things out of any given object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc@style\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<style>\n @ color    : chr \"black\"\n @ fill     : chr \"black\"\n @ linewidth: num 1\n```\n:::\n\n```{.r .cell-code}\ncc@points\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<points>\n @ x: num [1:100] 1 0.998 0.992 0.982 0.968 ...\n @ y: num [1:100] 0 0.0634 0.1266 0.1893 0.2511 ...\n```\n:::\n:::\n\n\nAs you can imagine, this is a handy feature in a generative art tool. Nevertheless it's a huge pain in the arse when it comes to constructing a new `circle` object. Fortunately we have...\n\n### Constructors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- new_class(\n  name = \"circle\",\n  parent = drawable,\n  properties = list(\n    x      = class_numeric,\n    y      = class_numeric,\n    radius = class_numeric,\n    n      = class_integer,\n    points = new_property(\n      class = points,\n      getter = function(self) {\n        angle <- seq(0, 2 * pi, length.out = self@n)\n        points(\n          x = self@x + self@radius * cos(angle),\n          y = self@y + self@radius * sin(angle)\n        )\n      }\n    )\n  ),\n  validator = function(self) {\n    if (length(self@x) != 1) return(\"x must be length 1\")\n    if (length(self@y) != 1) return(\"y must be length 1\")\n    if (length(self@radius) != 1) return(\"radius must be length 1\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (self@radius < 0) return(\"radius must be a non-negative number\")\n    if (self@n < 1L) return(\"n must be a positive integer\")\n  },\n  constructor = function(x = 0, y = 0, radius = 1, n = 100L, ...) {\n    new_object(\n      drawable(),\n      x = x,\n      y = y,\n      radius = radius,\n      n = n,\n      style = style(...)\n    )\n  }\n)\n```\n:::\n\n\nSo now I can create a circle in my preferred style in a natural way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- circle(radius = 2, fill = \"purple\")\ncc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<circle>\n @ style : <style>\n .. @ color    : chr \"black\"\n .. @ fill     : chr \"purple\"\n .. @ linewidth: num 1\n @ points: <points>\n .. @ x: num [1:100] 2 2 1.98 1.96 1.94 ...\n .. @ y: num [1:100] 0 0.127 0.253 0.379 0.502 ...\n @ x     : num 0\n @ y     : num 0\n @ radius: num 2\n @ n     : int 100\n```\n:::\n:::\n\n\n### Other drawables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshape <- new_class(\n  name = \"shape\",\n  parent = drawable,\n  properties = list(\n    x = class_numeric,\n    y = class_numeric,\n    points = new_property(\n      class = points,\n      getter = function(self) {\n        points(x = self@x, y = self@y)\n      }\n    )\n  ),\n  validator = function(self) {\n    if (length(self@x) != length(self@y)) {\n      \"x and y must be the same length\"\n    }\n  },\n  constructor = function(x, y, ...) {\n    new_object(\n      drawable(),\n      x = x,\n      y = y,\n      style = style(...)\n    )\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsq <- shape(\n  x = c(0, 0, 1, 1), \n  y = c(0, 1, 1, 0),\n  fill = \"red\"\n)\nsq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<shape>\n @ style : <style>\n .. @ color    : chr \"black\"\n .. @ fill     : chr \"red\"\n .. @ linewidth: num 1\n @ points: <points>\n .. @ x: num [1:4] 0 0 1 1\n .. @ y: num [1:4] 0 1 1 0\n @ x     : num [1:4] 0 0 1 1\n @ y     : num [1:4] 0 1 1 0\n```\n:::\n:::\n\n\n## Act II: Grid\n\n### Drawing drawables\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw <- new_generic(\"draw\", dispatch_args = \"object\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmethod(draw, drawable) <- function(object, xlim = NULL, ylim = NULL, ...) {\n\n  # plotting area is a single viewport with equal-axis scaling\n  if (is.null(xlim)) xlim <- range(object@points@x)\n  if (is.null(ylim)) ylim <- range(object@points@x)\n  x_width <- xlim[2] - xlim[1]\n  y_width <- ylim[2] - ylim[1]\n  vp <- grid::viewport(\n    xscale = xlim,\n    yscale = ylim,\n    width  = grid::unit(min(1, x_width / y_width), \"snpc\"),\n    height = grid::unit(min(1, y_width / x_width), \"snpc\"),\n  )\n\n  # shapes are always polygon grobs\n  grob <- grid::polygonGrob(\n    x = object@points@x,\n    y = object@points@y,\n    gp = grid::gpar(\n      col = object@style@color,\n      fill = object@style@fill,\n      lwd = object@style@linewidth\n    ),\n    vp = vp,\n    default.units = \"native\"\n  )\n\n  # draw the grob\n  grid::grid.newpage()\n  grid::grid.draw(grob)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw(cc)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw(sq)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### Making sketches\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsketch <- new_class(\n  name = \"sketch\",\n  properties = list(\n    shapes = new_property(class = class_list, default = list())\n  ),\n  validator = function(self) {\n    if (!all(purrr::map_lgl(self@shapes, \\(d) inherits(d, \"drawable\")))) {\n      \"shapes must be a list of drawable-classed objects\"\n    }\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmethod(draw, sketch) <- function(object, xlim = NULL, ylim = NULL, ...) {\n\n  # set default axis limits\n  if (is.null(xlim)) {\n    xlim <- c(\n      min(purrr::map_dbl(object@shapes, \\(s, id) min(s@points@x))),\n      max(purrr::map_dbl(object@shapes, \\(s, id) max(s@points@x)))\n    )\n  }\n  if (is.null(ylim)) {\n    ylim <- c(\n      min(purrr::map_dbl(object@shapes, \\(s) min(s@points@y))),\n      max(purrr::map_dbl(object@shapes, \\(s) max(s@points@y)))\n    )\n  }\n\n  # plotting area is a single viewport with equal-axis scaling\n  x_width <- xlim[2] - xlim[1]\n  y_width <- ylim[2] - ylim[1]\n  vp <- grid::viewport(\n    xscale = xlim,\n    yscale = ylim,\n    width  = grid::unit(min(1, x_width / y_width), \"snpc\"),\n    height = grid::unit(min(1, y_width / x_width), \"snpc\"),\n  )\n\n  # draw the grobs\n  grid::grid.newpage()\n  for(s in object@shapes) {\n    grob <- grid::polygonGrob(\n      x = s@points@x,\n      y = s@points@y,\n      gp = grid::gpar(\n        col = s@style@color,\n        fill = s@style@fill,\n        lwd = s@style@linewidth\n      ),\n      vp = vp,\n      default.units = \"native\"\n    )\n    grid::grid.draw(grob)\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsk <- sketch(list(cc, sq))\ndraw(sk)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n### Fallback methods\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethod(draw, class_any) <- function(object, ...) {\n  rlang::warn(\"Non-drawable objects ignored by draw()\")\n  return(invisible(NULL))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw(\"a string is not a drawable\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Non-drawable objects ignored by draw()\n```\n:::\n:::\n\n\n## Act III: Ambient\n\n\n### Blobs\n\nBlobs are essentially \"circles with a non-constant radius\", where the irregularity in the radius is a smoothly varying distortion created with Perlin noise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblob <- new_class(\n  name = \"blob\",\n  parent = drawable,\n  properties = list(\n    x          = class_numeric,\n    y          = class_numeric,\n    radius     = class_numeric,\n    range      = class_numeric,\n    n          = class_integer,\n    frequency  = class_numeric,\n    octaves    = class_integer,\n    seed       = class_integer,\n    points = new_property(\n      class = points,\n      getter = function(self) {\n        angle <- seq(0, 2*pi, length.out = self@n)\n        pointwise_radius <- ambient::fracture(\n          noise = ambient::gen_simplex,\n          fractal = ambient::fbm,\n          x = self@x + cos(angle) * self@radius,\n          y = self@y + sin(angle) * self@radius,\n          frequency = self@frequency,\n          seed = self@seed,\n          octaves = self@octaves\n        ) |>\n          ambient::normalize(to = self@radius + c(-1, 1) * self@range)\n        points(\n          x = self@x + pointwise_radius * cos(angle),\n          y = self@y + pointwise_radius * sin(angle)\n        )\n      }\n    )\n  ),\n  constructor = function(x = 0,\n                         y = 0,\n                         radius = 1,\n                         range = 0.2,\n                         n = 100L,\n                         frequency = 1,\n                         octaves = 2L,\n                         seed = 1L,\n                         ...) {\n    new_object(\n      drawable(),\n      x = x,\n      y = y,\n      radius = radius,\n      range = range,\n      n = n,\n      frequency = frequency,\n      octaves = octaves,\n      seed = seed,\n      style = style(...)\n    )\n  },\n  validator = function(self) {\n    if (length(self@x) != 1) return(\"x must be length 1\")\n    if (length(self@y) != 1) return(\"y must be length 1\")\n    if (length(self@radius) != 1) return(\"radius must be length 1\")\n    if (length(self@range) != 1) return(\"range must be length 1\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (length(self@frequency) != 1) return(\"frequency must be length 1\")\n    if (length(self@octaves) != 1) return(\"octaves must be length 1\")\n    if (length(self@seed) != 1) return(\"seed must be length 1\")\n    if (self@radius < 0) return(\"radius must be a non-negative number\")\n    if (self@range < 0) return(\"range must be a non-negative number\")\n    if (self@frequency < 0) return(\"frequency must be a non-negative number\")\n    if (self@n < 1L) return(\"n must be a positive integer\")\n    if (self@octaves < 1L) return(\"octaves must be a positive integer\")\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbb <- blob(n = 500L)\ndraw(bb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\nSo, using the rainbow `palette` I defined at the top of the post:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalues <- tibble::tibble(\n  x = cos(seq(0, pi * 5/3, length.out = 6)),\n  y = sin(seq(0, pi * 5/3, length.out = 6)),\n  n = 500L,\n  fill = palette,\n  color = fill\n)\n\nblobs <- purrr::pmap(values, blob)\nblobs |> sketch() |> draw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n### Ribbons\n\nRibbons are similar to blobs, but the polygon is defined by movement along a line rather than around a circle:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nribbon <- new_class(\n  name = \"ribbon\",\n  parent = drawable,\n  properties = list(\n    x          = class_numeric,\n    y          = class_numeric,\n    xend       = class_numeric,\n    yend       = class_numeric,\n    width      = class_numeric,\n    n          = class_integer,\n    frequency  = class_numeric,\n    octaves    = class_integer,\n    seed       = class_integer,\n    points = new_property(\n      class = points,\n      getter = function(self) {\n        x <- seq(self@x, self@xend, length.out = self@n)\n        y <- seq(self@y, self@yend, length.out = self@n)\n        displacement <- ambient::fracture(\n          noise = ambient::gen_simplex,\n          fractal = ambient::fbm,\n          x = x,\n          y = y,\n          frequency = self@frequency,\n          seed = self@seed,\n          octaves = self@octaves\n        ) |>\n          ambient::normalize(to = c(0, 1))\n        taper <- sqrt(\n          seq(0, 1, length.out = self@n) * seq(1, 0, length.out = self@n)\n        )\n        width <- displacement * taper * self@width\n        dx <- self@xend - self@x\n        dy <- self@yend - self@y\n        points(\n          x = c(x - width * dy, x[self@n:1L] + width[self@n:1L] * dy),\n          y = c(y + width * dx, y[self@n:1L] - width[self@n:1L] * dx)\n        )\n      }\n    )\n  ),\n  constructor = function(x = 0,\n                         y = 0,\n                         xend = 1,\n                         yend = 1,\n                         width = 0.2,\n                         n = 100L,\n                         frequency = 1,\n                         octaves = 2L,\n                         seed = 1L,\n                         ...) {\n    new_object(\n      drawable(),\n      x = x,\n      y = y,\n      xend = xend,\n      yend = yend,\n      width = width,\n      n = n,\n      frequency = frequency,\n      octaves = octaves,\n      seed = seed,\n      style = style(...)\n    )\n  },\n  validator = function(self) {\n    if (length(self@x) != 1) return(\"x must be length 1\")\n    if (length(self@y) != 1) return(\"y must be length 1\")\n    if (length(self@xend) != 1) return(\"xend must be length 1\")\n    if (length(self@yend) != 1) return(\"yend must be length 1\")\n    if (length(self@width) != 1) return(\"width must be length 1\")\n    if (length(self@n) != 1) return(\"n must be length 1\")\n    if (length(self@frequency) != 1) return(\"frequency must be length 1\")\n    if (length(self@octaves) != 1) return(\"octaves must be length 1\")\n    if (length(self@seed) != 1) return(\"seed must be length 1\")\n    if (self@width < 0) return(\"width must be a non-negative number\")\n    if (self@frequency < 0) return(\"frequency must be a non-negative number\")\n    if (self@n < 1L) return(\"n must be a positive integer\")\n    if (self@octaves < 1L) return(\"octaves must be a positive integer\")\n  }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrb <- ribbon(n = 500L)\ndraw(rb)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(101L)\nvalues <- tibble::tibble(\n  x = rnorm(200L, sd = 1.5),\n  y = rnorm(200L, sd = 1.5),\n  xend = x + 1,\n  yend = y,\n  width = 1,\n  n = 500L,\n  fill = sample(palette, 200L, replace = TRUE),\n  color = fill\n)\n\nribbons <- purrr::pmap(values, ribbon)\nribbons |> \n  sketch() |> \n  draw(xlim = c(-2, 2), ylim = c(-2, 2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}