{
  "hash": "2a7840bb1b10a5f0c13fbb62f6c04c38",
  "result": {
    "markdown": "---\ntitle: \"Software design by example\"\ndescription: \"A book review, sort of. Not really.\"\ndate: \"2023-05-28\"\n---\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nThe book I'm currently reading is [Software Design by Example: A Tool-Based Introduction with JavaScript](https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-JavaScript/Wilson/p/book/9781032330235) by [Greg Wilson](https://third-bit.com/). Greg was kind enough to send me a review copy a little while back, and I've been slowly working my way through it. \n\nIn some ways I'm not the target audience for the book: it's a book about software engineering that uses javascript for the worked examples, not a book designed to teach you javascript. I'm not the worst javascript coder in the world, but I'm not the strongest either, so it's harder work for me than maybe it would have been if javascript were my primary language. That said, I'm finding the book rewarding. The glossary at the end is particularly helpful. I never received a \"proper\" education in programming, and I commonly have the experience in conversation that software engineers use terms that -- though they are rarely complicated ideas -- no-one has ever explained to me. \n\nAs an example, here's a section from the glossary on the top of page 318:\n\n> |\n- **query string**. The portion of a **URL** after the question mark ? that specfies extra parameters for the **HTTP request** as name-value pairs\n- **race condition**. A situation in which a result depend on the order in which two or more concurrent operations are carried out.\n- **raise (an exception)**. To signal that something unexpected or unusual has happened in a program by creating an **exception** and handling it to the **error-handling** system, which then tries to find a point in the program that will **catch** it.\n- **read-eval-print-loop (REPL)**. An interactive program that reads a command typed in by a user, executes it, prints the result, and then waits patiently for the next command. REPLs are often used to explore new ideas, or for debugging.\n\nI can honestly say that at no point in my life has someone explained to me what a \"race condition\" is or what a REPL does. When I read entries like this in the glossary I find myself going \"oh, right, I did already know this... but now I know what the name for it is\". Race conditions are not unfamiliar to me (I encounter them quite a bit) but because software engineers have a tendency to talk to \"race conditions\" without ever saying what the term means, I've sat in a lot of very confusing conversations in the past that would have made perfect sense had I known the nomenclature.\n\nI think that's likely to be true for a lot of self-taught programmers who never studied computer science, but instead had to learn to code in order to solve practical problems. The mere act of reading a concise definition of each thing has the effect of making my mental model more precise. It's a helpful way to learn the culture and avoid getting caught out by the various [shibboleths](https://en.wikipedia.org/wiki/Shibboleth) that pervade the tech industry. \n\nThere are other examples of this sort of thing throughout the book, historical anecdotes and other tidbits that make it a little easier for an outsider to make sense of the culture of software engineering. As an example, this little passage on p145 makes sense of something I've never understood:\n\n> The coordinate systems for screens puts (0, 0) in the upper left corner instead of the lower left. X increases to the right as usual, but Y increases as we go down, rather than up [The book has a little picture here]. This convention is a holdover from the days of teletype terminals that printed lines on rolls of paper\n\nThese historical asides are really valuable. It feels a little bit like one of those \"Magician's Secrets Revealed!\" shows. Knowing the terminology, conventions, and history behind a thing does so much of the work in making it all feel a bit more coherent. \n\n## An example goes here\n\n\n<!--------------- appendices go here ----------------->\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}