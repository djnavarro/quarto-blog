{
  "hash": "740a24e4657d2e594903bcb30e27cd9b",
  "result": {
    "markdown": "---\ntitle: \"Playing around with WebR\"\nauthor:\n  - name: Danielle Navarro\n    url: https://djnavarro.net\n    affiliation: I'm on smoko\n    affiliation-url: https://www.youtube.com/watch?v=j58V2vC9EPc\n    orcid: 0000-0001-7648-6578\ndescription: \"playing with webr\"\ndate: \"2023-04-09\"\ncategories: [R, WebR]\nimage: automaton1.png\n---\n\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nI made a little cellular automaton using webr: [webr-automata.djnavarro.net](https://webr-automata.djnavarro.net/). The source code is on github at [https://github.com/djnavarro/webr-automata](https://github.com/djnavarro/webr-automata)\n\n:::{.column-screen-inset}\n:::{layout-ncol=3} \n\n![](automaton1.png)\n\n![](automaton2.png)\n\n![](automaton3.png)\n\n:::\n:::\n\n## The R code\n\nIt's built around an R function called `make_art()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_art <- function(str = NULL,\n                     linebreak = \"<br>\", \n                     n_rows = 30,\n                     n_cols = 50,\n                     iterations = 100,\n                     symbols = c(\"░\", \"▒\", \"▓\", \"█\")) {\n\n  # create random string if none is given\n  if(is.null(str)) {\n    str <- sample(symbols, n_rows * n_cols, TRUE)\n    str <- paste(str, collapse = \"\")\n  }\n\n  # make matrix from (possibly break-delimited) string\n  str <- gsub(\n    pattern = linebreak, \n    replacement = \"\", \n    x = str, \n    fixed = TRUE\n  )\n  dat <- matrix(\n    data = strsplit(str, \"\")[[1]], \n    nrow = n_rows, \n    ncol = n_cols, \n    byrow = TRUE\n  )\n\n  # run simple automaton\n  for(i in 1:iterations) {\n    r <- sample(2:(n_rows-1), 1)\n    c <- sample(2:(n_cols-1), 1)\n    h <- sample(-1:1, 1)\n    v <- sample(-1:1, 1)\n    dat[r+v, c+h] = dat[r, c]\n  }\n\n  # convert matrix to string and return \n  str <- \"\"\n  for(i in 1:n_rows) {\n    row <- paste(dat[i, ], collapse=\"\")\n    str <- paste(str, row, sep = linebreak)\n  }\n  str <- paste(str, linebreak, sep = \"\")\n  str\n}\n```\n:::\n\n\nHere's what it does:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_f32887380a6457374569ee14fc150f99'}\n\n```{.r .cell-code}\nset.seed(1)\nstr <- make_art(\n  linebreak = \"\\n\", \n  n_rows = 20,\n  n_cols = 60,\n  iterations = 100000\n)\ncat(str)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n█▒▒▒▒▒█▒░░░░░▓▓▓░░░░░░░░░░░░░░█░██████▒██████████████▓███▓▓▓\n▒▒▒▒▒▒▒▒░▒▓░░▓▓░░░░░░░░░░░░░░░░█░░███▒███████████░░██████▓▓▓\n█▒▒▒▒▒▒▒░░▓▓▓▓▓░░░░░░░░░░░░░░░░░░███▒████████████████▓▓▓▓▓▓▓\n█▒▒▒█▒▒▒▒░▒▓▓▓▓░░░░░░░░░░░░░░░░░████▒▒████████████████▓▓▓█▓▓\n██▒▒███▒▒▒▒▓▒▓░▒░░░░░░░░░░░░░░░░█████▒▒████████████░░█░▓▓▓██\n▒██▒▒▒▒██▒▓▓▒▓▓▓▒▒░░░░░▒░░░░░█░░░███▒▒▒████████████░░░░▓▓███\n▒▒▒▒▒▒▒▒▒▓▓▒▓▓▒▒▒▒▓░░░░░░░░░░█░█████▒▒▒████████████░░█░████░\n▒▒▒▒▒▒▒▒▒▒▓▒▓▒▓▒▒▓▒░░░▒░░░░▒▒█░███████▒██████▒▒████░░██████░\n▒▒▒▒▒▒▒▒▒▓▓▓▓▓▒▒▒▒░▓▓░▒▒▒▒░██░████████████▒██▒███████░░░░█░█\n▒▒▒▒▒▒▒▒▒▓▒▒▒▒▒▒▒█▓▓█▒▒░▒▒▒██░░███████████▒▒▒█▒█▒█▒████░█░██\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▓████░██▒▒██░░░██▒███████████▒▒███████░██░\n▒▒▒▒▒▒▒▓▒▓▓▒░▒▒▒▒▓░░░█░░█▓▓▓░██░░░▒▒▒█▒███▒█▓█████████░░█░█░\n▒▒▒▒▒▒▒▒▓▒▒▒▒░░▒▓▒░░░░░░░▓▓▓████▓▓▒▒▒▒▒██▒▒▓▒▒▒▒████░░░░░███\n▒▒▒▒▒▒▒▒▓▒▒░▒▒░░░▓░░░░░░▓▓░▓█████▓▓▓▒▒█▒█▒▓▒▒▒▒▒▒█████░░░░█░\n▒▒▒▒▒▒▒▒▒░▒▓▒▒▒░░░▒░█░░░░░█░▓████▓▓▓▓▓█▒▒▓▓▒▓░░▒▒▒█▒███░░░░░\n▒▒▒▒▒▒▒▒▒░░▒▒▒▒░▒░▒▒▒░░░░██░░░░░▓▓▓▓▓████▒▒▒▒▒░▒▒▒▒▒██░░░░░░\n▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░█▒░░░░░░░░░░░░▓▓▓▓█▓█▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░█░░░░░░░░░░░░░▓▓▓▓▓▓▓▓██▒▒▒▒▒▒▒▒▒▒▒▒░░░░░█░\n▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░█░░░░░░░░░░░░░▓▓▓▓▓▓██▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░█\n▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░█░█▓▓▓▓▓▓▓██▒▒▒▒▒▒▒▒▒▓▒▒░░░████\n```\n:::\n:::\n\n\nLet's imagine we have this saved to an R script called `art.R`.\n\n## The HTML\n\nThe html code for the site is very simple: it creates an empty div called \"grid\" for the javascript to modify, and sources a cript called `webr-app.js` that does all the work:\n\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Text Textures</title>\n  </head>\n  <body>\n    <div id=\"grid\">webR is starting, please wait...</div>\n    <script src=\"./webr-app.js\"></script>\n  </body>\n</html>\n```\n\n## The Javascript\n\nHere's the source code for `webr-app.js`:\n\n::: {.column-body-outset}\n\n``` javascript\n// import the webr module and then run the code\nimport('https://webr.r-wasm.org/latest/webr.mjs').then(async ({WebR}) => {\n\n    // the HTML element showing the grid\n    let grid = document.getElementById(\"grid\");\n\n    // wait for the webR session to start\n    const webr = new WebR();\n    await webr.init();\n\n    // read the R source code as a JS string\n    let art_src = fetch('art.R').then((response) => {return response.text()});\n\n    // evaluate the R source code, defining make_art() in the R environment\n    await webr.evalR(await art_src);\n\n    // initialise the state of the grid by calling make_art() with no input,\n    // pull the output into JS, and use it to update the state of the grid\n    let art_r = await webr.evalR('make_art()')\n    let art_js = await art_r.toJs();\n    grid.innerHTML = art_js.values;\n\n    // function to update the state of the grid\n    async function grid_update() {\n        await webr.objs.globalEnv.bind('str', grid.innerHTML) // copy the grid string into R\n        let art_r = await webr.evalR('make_art(str)')         // pass string to make_art()\n        let art_js = await art_r.toJs();                      // pull the output back to JS\n        grid.innerHTML = art_js.values;                       // update the grid string\n    }\n\n    // repeatedly call the update function\n    while (true) {\n        await grid_update();\n    }\n});\n```\n\n:::\n\n\n\n<!--------------- appendices go here ----------------->\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}