{
  "hash": "67db2635fc147c30a9e180ba7de3d755",
  "result": {
    "markdown": "---\ntitle: \"Playing with docker and the github container registry\"\nauthor:\n  - name: Danielle Navarro\n    url: https://djnavarro.net\n    affiliation: I'm on smoko\n    affiliation-url: https://www.youtube.com/watch?v=j58V2vC9EPc\n    orcid: 0000-0001-7648-6578\ndescription: \"There is no reason for this.\"\ndate: \"2023-01-01\"\ncategories: [Linux, R, Docker]\nimage: \"whales.png\"\n---\n\n\n<!-- image credit: \n  Teng Yuhong\n  https://unsplash.com/photos/qMehmIyaXvY\n-->\n\n<!--------------- my typical setup ----------------->\n\n\n\n\n\n<!--------------- post begins here ----------------->\n\nDocker docker docker baby. This is a post about docker, and on the off chance that you've been living under a rock for the last several years, docker^[Look, I know it's technically supposed to be \"Docker\" not \"docker\" and it's supposed to be \"GitHub\" not \"github\". But my body was \"supposed\" to use testosterone as its primary sex hormone too, and we've all seen how little regard I had for that. Sometimes conventions are worth breaking out of sheer bloody-mindedness.] allows you to run your code within a \"container\" that isolates it from other processes running on your machine. Containers are a bit like virtual machines, but smaller, more portable, and don't require you to have a complete copy of a second operating system running on your machine. They're... actually, you know what? Why don't I quote the relevant paragraphs from [the docker website](https://www.docker.com/resources/what-container/):\n\n> **CONTAINERS**: Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel^[STEM people need to find new words for things. What is a \"kernel\"? Is it the bits of an operating system that run essential processes? Is it a specialised function that applies only to input arguments of specific types (i.e., what R folks would call a \"method\" in the functional object oriented programming sense, as opposed to the encapsulated object-oriented programming paradigm that dominates in other languages)? Or is it the thing the governs the transformation from data space to feature space in a support vector machine or other inferential systems built on reproducing kernel Hilbert Spaces? For fuck's sake people LEARN A NEW WORD] with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems.\n>\n> **VIRTUAL MACHINES**: Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries – taking up tens of GBs. VMs can also be slow to boot.\n\nThey even have pretty pictures on the website. I thought about reproducing their figures for this blog post but why bother? If you want to look at their pictures you can go look at the website and in any case I think we can all agree that making these cute whale graphics with ggplot2 was a much better use of my time, yes?\n\n\n::: {.cell .column-screen-inset layout-align=\"center\" fig.dpi='200'}\n::: {.cell-output-display}\n![](index_files/figure-html/whale-row-1-1.png){fig-align='center' width=1536}\n:::\n:::\n\n\nAnyway. I've been meaning to teach myself docker for a few years now. It's one of those \"things\" that has this weird aura of being difficult when it... doesn't seem to be all that difficult? For a long time I've had this feeling of dread or insecurity about it, thinking that it must be \"too technical\" for me.^[Sometimes I think that the \"not technical enough\" concept is just straight up misogyny, both internalised and... external. I mean, I taught myself Bayesian nonparametrics and algorithmic information theory and even wrote respected academic papers in both those fields in addition to my own discipline of mathematical psychology. I was an editor at Science (yes, the journal). I wrote a quite successful statistics textbook. I'm an author on the ggplot2 book. I was a successful tenured academic in a mathematical science with no formal training in mathematics. I've taught myself several programming languages. Last year I wrote quite a lot of Apache Arrow content that everyone seems to like. So, um, yeah. Perhaps I should stop paying attention to the opinions of boys who don't think I'm technical enough because I'm stronger in R than Python or C++.] I have no doubt that the internals to docker are complicated, and there are subtleties to using docker well that will take a while to grasp, but when I managed to set aside my fears and read the documentation it turned out that the basics were surprisingly easy. \n\n## Installing docker\n\nThe [installation guides](https://docs.docker.com/get-docker/) on the docker website are good, and have information for various operating systems. I'm doing this on my ubuntu laptop^[Yes I know [I use Arch now](https://blog.djnavarro.net/posts/2022-12-31_btw-i-use-arch/), hush. you'll see why I'm doing this from ubuntu in a moment...] so I followed the [ubuntu install guide](https://docs.docker.com/engine/install/ubuntu/). I also went a little further and followed the [post-install instructions for linux](https://docs.docker.com/engine/install/linux-postinstall/) so that I could run docker commands without requiring superuser privileges: that's the reason you won't see any `sudo` commands in this post. Obviously, that's something that will be a bit different on different operating systems and I'm not trying to write a tutorial here, but if you are using this post as a resource you can check that everything is working on your own installation by running this command:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker run hello-world\n```\n\n\n::: {.cell-output .cell-output-stdout}\n```\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n```\n:::\n:::\n\n\nOkay that looks good. Seems to be running on my machine. As an aside, as long as you are online you don't need to have a copy `hello-world` itself for this to work: docker will download it for you when you run the command. \n\n## Terminology\n\nBefore diving in and using docker, it helps to disambiguate three terms:\n\n- **Container**. A container is an executable. It runs on your machine isolated from other processes, has a namespace on the kernel, etc. Setting the particulars aside, it *is* a computing environment.\n- **Image**. An image is a read-only template that contains the instruction to build a container. It's a \"snapshot\" of a computing environment, constructed from one or more \"layers\" of build steps. Images are binaries that are stored locally and hosted on various registries. More on that later! \n- **Dockerfile**. Finally, there's the dockerfile.^[I'm sure that's supposed to be \"Docker file\". Per my earlier footnote, I don't care.] That's a plain text file that you as the user write. It contains the instructions for how to construct an image. They supply, in a (very!) abstract sense, the source code for an image. \n\nSo it works like this. You use a dockerfile to **build** an image, the image contains the instructions to **run** a container, and the corresponding commands are quite sensibly called `docker build` and `docker run`. Or if you like diagrams with labelled arrows... \n\n$$\n\\mbox{dockerfile} \\xrightarrow{\\mbox{build}} \\mbox{image} \\xrightarrow{\\mbox{run}} \\mbox{container}\n$$\nShall we have a go at this then?\n\n## Minimal example\n\nTo begin with, we'll keep things simple. Accompanying this post is a project called [`system-check`](https://github.com/djnavarro/quarto-blog/tree/main/posts/2023-01-01_playing-with-docker/system-check) that consists of one brief dockerfile and one small R script. Here is the complete source code for both of them:\n\n\n::: {.cell filename='./system-check/Dockerfile'}\n\n```{.dockerfile .cell-code}\nFROM ghcr.io/djnavarro/arch-r:base\nCOPY script.R /home/script.R\nCMD Rscript /home/script.R\n```\n:::\n\n::: {.cell filename='./system-check/script.R'}\n\n```{.r .cell-code}\ncat(c(\"Running on:\", osVersion), sep = \"\\n  \")\ncat(c(\"With locale:\", strsplit(Sys.getlocale(), \";\")[[1]]), sep = \"\\n  \")\n```\n:::\n\n::: {.cell .column-margin}\n::: {.cell-output-display}\n![This was the first iteration of the whale system](index_files/figure-html/whale-1-1.png){width=672}\n:::\n:::\n\n\n\nBuild it:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build --tag my-system-check system-check\n```\n:::\n\n\n```\nSending build context to Docker daemon  3.072kB\nStep 1/3 : FROM ghcr.io/djnavarro/arch-r:base\nbase: Pulling from djnavarro/arch-r\n597018910566: Already exists \n8150bcc6bc64: Already exists \nc2ff38743c81: Pull complete \nc5dd676c14d5: Pull complete \nf30b21a3d71a: Pull complete \n8545f2705041: Pull complete \nDigest: sha256:5cd9e80d7263aabf541c2a2c7efe95b1482e8132ee9c3e6a744c3e54e8cade7a\nStatus: Downloaded newer image for ghcr.io/djnavarro/arch-r:base\n ---> c74e54ffdd8c\nStep 2/3 : COPY script.R /home/script.R\n ---> 50c0c119b6d2\nStep 3/3 : CMD Rscript /home/script.R\n ---> Running in fa9d38781c17\nRemoving intermediate container fa9d38781c17\n ---> fed061a96fec\nSuccessfully built fed061a96fec\nSuccessfully tagged my-system-check:latest\n```\n\nThe \"already exists\" part of the output is worth commenting on. I'd been playing around with some of the images upon which `ghcr.io/djnavarro/arch-r:base` is built earlier (e.g., it's built on an Arch Linux image that I already have on my laptop) and docker is smart enough to realise it only has to download and build some layers. That's a really nice feature. Among other things, it means that if if I try building this image as second time, docker can use the cached copies of the build steps because nothing has changed and it doesn't have to do anything:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build --tag my-system-check system-check\n```\n:::\n\n\n```\nSending build context to Docker daemon  3.072kB\nStep 1/3 : FROM ghcr.io/djnavarro/arch-r:base\n ---> c74e54ffdd8c\nStep 2/3 : COPY script.R /home/script.R\n ---> Using cache\n ---> 50c0c119b6d2\nStep 3/3 : CMD Rscript /home/script.R\n ---> Using cache\n ---> fed061a96fec\nSuccessfully built fed061a96fec\nSuccessfully tagged my-system-check:latest\n```\n\nNext tell docker to run it. Note that I'm referring to the image by name:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker run my-system-check\n```\n:::\n\n\n```\nRunning on:\n  Arch Linux\nWith locale:\n  LC_CTYPE=en_US.UTF-8\n  LC_NUMERIC=C\n  LC_TIME=en_US.UTF-8\n  LC_COLLATE=en_US.UTF-8\n  LC_MONETARY=en_US.UTF-8\n  LC_MESSAGES=en_US.UTF-8\n  LC_PAPER=en_US.UTF-8\n  LC_NAME=C\n  LC_ADDRESS=C\n  LC_TELEPHONE=C\n  LC_MEASUREMENT=en_US.UTF-8\n  LC_IDENTIFICATION=C\n````\n\nCompare this to what happens if I run the script outside the docker image:\n\n::: {.cell}\n\n```{.bash .cell-code}\nRscript script.R\n```\n:::\n\n```\nRunning on:\n  Ubuntu 22.04.1 LTS\nWith locale:\n  LC_CTYPE=en_AU.UTF-8\n  LC_NUMERIC=C\n  LC_TIME=en_AU.UTF-8\n  LC_COLLATE=en_AU.UTF-8\n  LC_MONETARY=en_AU.UTF-8\n  LC_MESSAGES=en_AU.UTF-8\n  LC_PAPER=en_AU.UTF-8\n  LC_NAME=C\n  LC_ADDRESS=C\n  LC_TELEPHONE=C\n  LC_MEASUREMENT=en_AU.UTF-8\n  LC_IDENTIFICATION=C\n```\n\n\n::: {.cell .column-screen-inset layout-align=\"center\" fig.dpi='200'}\n::: {.cell-output-display}\n![](index_files/figure-html/whale-row-2-1.png){fig-align='center' width=1536}\n:::\n:::\n\n\n## Fancier example\n\nLet's take a look at a slightly fancier version. Images created using [`test-on-arch`](https://github.com/djnavarro/quarto-blog/tree/main/posts/2023-01-01_playing-with-docker/test-on-arch) download an R package from a github repository, install any dependencies of the package, and then run `R CMD check` within an Arch Linux environment. Again it consists of two files, a dockerfile and an R script. Here they are:\n\n\n::: {.cell filename='./test-on-arch/Dockerfile'}\n\n```{.dockerfile .cell-code}\nFROM ghcr.io/djnavarro/arch-r:test\n\n# copy the testing script\nCOPY clone-and-check.R /home/clone-and-check.R\n\n# pass args through environment variables\nARG user\nARG repo\nENV user=$user\nENV repo=$repo\n\n# run the testing script\nCMD Rscript /home/clone-and-check.R\n```\n:::\n\n::: {.cell filename='./test-on-arch/clone-and-check.R'}\n\n```{.r .cell-code}\n# get the system environment variables\nuser <- Sys.getenv(\"user\")\nrepo <- Sys.getenv(\"repo\")\ncran <- Sys.getenv(\"cran\")\n\n# define github url and a path for the local package install\nurl <- paste(\"https://github.com\", user, repo, sep = \"/\")\ndir <- paste(\"/home/project\", repo, sep=\"/\")\n\n# clone repo, install dependencies, and run checks\ngert::git_clone(url, dir, verbose = TRUE)\nremotes::install_deps(dir, dependencies = TRUE, repos = cran)\nrcmdcheck::rcmdcheck(dir)\n```\n:::\n\n\nNotice that I'm building on top of a slightly different image. The `system-check` image starts by building from `ghcr.io/djnavarro/arch-r:base`, whereas `test-on-check` uses `ghcr.io/djnavarro/arch-r:test`. The two are related: `arch-r:test` takes `arch-r:base` as its starting point and adds some system and R packages that are super-handy when building an R package and running its unit tests. \n\n\n::: {.cell .column-margin}\n::: {.cell-output-display}\n![I need a different plot here](index_files/figure-html/whale-2-1.png){width=672}\n:::\n:::\n\n\nLet's see what happens when I try to build:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build \\\n  --tag test-queue \\\n  --build-arg user=djnavarro \\\n  --build-arg repo=queue \\\n  test-on-arch\n```\n:::\n\n\n```\nSending build context to Docker daemon  3.072kB\nStep 1/7 : FROM ghcr.io/djnavarro/arch-r:test\ntest: Pulling from djnavarro/arch-r\n597018910566: Already exists \n8150bcc6bc64: Already exists \nc2ff38743c81: Already exists \nc5dd676c14d5: Already exists \nf30b21a3d71a: Already exists \n8545f2705041: Already exists \nd64243188ff1: Pull complete \n98bfb679f27b: Pull complete \n6627d8db8438: Pull complete \nDigest: sha256:9eb6e1c28f7ebe30acbd320fe2d47ca8e356bdc582e633bd3b55eaab0ef03bc0\nStatus: Downloaded newer image for ghcr.io/djnavarro/arch-r:test\n ---> 549fdff95a53\nStep 2/7 : COPY clone-and-check.R /home/clone-and-check.R\n ---> 90635e60ba89\nStep 3/7 : ARG user\n ---> Running in 19c6fd3b47ce\nRemoving intermediate container 19c6fd3b47ce\n ---> aaf0a7677e56\nStep 4/7 : ARG repo\n ---> Running in 9ea3246bded6\nRemoving intermediate container 9ea3246bded6\n ---> edfa009a9757\nStep 5/7 : ENV user=$user\n ---> Running in ea2dcd08d511\nRemoving intermediate container ea2dcd08d511\n ---> 738933de7e6c\nStep 6/7 : ENV repo=$repo\n ---> Running in fe9b2b07a311\nRemoving intermediate container fe9b2b07a311\n ---> 9361bae891f3\nStep 7/7 : CMD Rscript /home/clone-and-check.R\n ---> Running in ffdb933cf785\nRemoving intermediate container ffdb933cf785\n ---> 9fbbbbe1188d\nSuccessfully built 9fbbbbe1188d\nSuccessfully tagged test-queue:latest\n```\n\nIt downloads, but this is a much larger image because the testing environment has tex-live installed on it (among other things) and it's a few GB in size. This one isn't a frugal image! It takes a while but the nice thing is that if you've done it once you don't have to do it again.\n\n\nAs a little sanity check -- because, dear reader, I have been sitting here waiting very patiently while a large image downloaded over a slow connection and would like to confirm that I don't have to do that again -- let's repeat the exercise from earlier and try building it a second time:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build \\\n  --tag test-queue \\\n  --build-arg user=djnavarro \\\n  --build-arg repo=queue \\\n  test-on-arch \n```\n:::\n\n\n```\nSending build context to Docker daemon  3.072kB\nStep 1/7 : FROM ghcr.io/djnavarro/arch-r:test\n ---> 549fdff95a53\nStep 2/7 : COPY clone-and-check.R /home/clone-and-check.R\n ---> Using cache\n ---> 90635e60ba89\nStep 3/7 : ARG user\n ---> Using cache\n ---> aaf0a7677e56\nStep 4/7 : ARG repo\n ---> Using cache\n ---> edfa009a9757\nStep 5/7 : ENV user=$user\n ---> Using cache\n ---> 738933de7e6c\nStep 6/7 : ENV repo=$repo\n ---> Using cache\n ---> 9361bae891f3\nStep 7/7 : CMD Rscript /home/clone-and-check.R\n ---> Using cache\n ---> 9fbbbbe1188d\nSuccessfully built 9fbbbbe1188d\nSuccessfully tagged test-queue:latest\n```\n\nNot going to lie, I breathed a little sigh of relief. Docker used the cached layers, and that all happened instantaneously. \n\nNow let's run it:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker run test-queue\n```\n:::\n\n\n```\nTransferred 766 of 766 objects...done!\nChecked out 34 of 34 commits... done!\n\n── R CMD build ─────────────────────────────────────────────────────────────────\n* checking for file ‘.../DESCRIPTION’ ... OK\n* preparing ‘queue’:\n* checking DESCRIPTION meta-information ... OK\n* installing the package to build vignettes\n* creating vignettes ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\n* building ‘queue_0.0.2.tar.gz’\n\n── R CMD check ─────────────────────────────────────────────────────────────────\n* using log directory ‘/tmp/Rtmp5JJJOo/file1487d1ddf/queue.Rcheck’\n* using R version 4.2.2 (2022-10-31)\n* using platform: x86_64-pc-linux-gnu (64-bit)\n* using session charset: UTF-8\n* checking for file ‘queue/DESCRIPTION’ ... OK\n* this is package ‘queue’ version ‘0.0.2’\n* package encoding: UTF-8\n* checking package namespace information ... OK\n* checking package dependencies ... OK\n* checking if this is a source package ... OK\n* checking if there is a namespace ... OK\n* checking for executable files ... OK\n* checking for hidden files and directories ... OK\n* checking for portable file names ... OK\n* checking for sufficient/correct file permissions ... OK\n* checking whether package ‘queue’ can be installed ... OK\n* checking installed package size ... OK\n* checking package directory ... OK\n* checking ‘build’ directory ... OK\n* checking DESCRIPTION meta-information ... OK\n* checking top-level files ... OK\n* checking for left-over files ... OK\n* checking index information ... OK\n* checking package subdirectories ... OK\n* checking R files for non-ASCII characters ... OK\n* checking R files for syntax errors ... OK\n* checking whether the package can be loaded ... OK\n* checking whether the package can be loaded with stated dependencies ... OK\n* checking whether the package can be unloaded cleanly ... OK\n* checking whether the namespace can be loaded with stated dependencies ... OK\n* checking whether the namespace can be unloaded cleanly ... OK\n* checking loading without being on the library search path ... OK\n* checking dependencies in R code ... NOTE\nNamespaces in Imports field not imported from:\n  ‘callr’ ‘cli’ ‘R6’ ‘tibble’\n  All declared Imports should be used.\n* checking S3 generic/method consistency ... OK\n* checking replacement functions ... OK\n* checking foreign function calls ... OK\n* checking R code for possible problems ... OK\n* checking Rd files ... OK\n* checking Rd metadata ... OK\n* checking Rd cross-references ... OK\n* checking for missing documentation entries ... OK\n* checking for code/documentation mismatches ... OK\n* checking Rd \\usage sections ... OK\n* checking Rd contents ... OK\n* checking for unstated dependencies in examples ... OK\n* checking installed files from ‘inst/doc’ ... OK\n* checking files in ‘vignettes’ ... OK\n* checking examples ... OK\n* checking for unstated dependencies in ‘tests’ ... OK\n* checking tests ...\n  Running ‘testthat.R’\n OK\n* checking for unstated dependencies in vignettes ... OK\n* checking package vignettes in ‘inst/doc’ ... OK\n* checking running R code from vignettes ...\n  ‘queue.Rmd’ using ‘UTF-8’... OK\n NONE\n* checking re-building of vignette outputs ... OK\n* checking PDF version of manual ... OK\n* DONE\n\nStatus: 1 NOTE\nSee\n  ‘/tmp/Rtmp5JJJOo/file1487d1ddf/queue.Rcheck/00check.log’\nfor details.\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\nFailed to connect to bus: Host is down\nWarning: Your system is mis-configured: ‘/var/db/timezone/localtime’ is not a symlink\nWarning: ‘/var/db/timezone/localtime’ is not identical to any known timezone file\nWarning message:\nIn system(\"timedatectl\", intern = TRUE) :\n  running command 'timedatectl' had status 1\n── R CMD check results ──────────────────────────────────────── queue 0.0.2 ────\nDuration: 39.9s\n\n❯ checking dependencies in R code ... NOTE\n  Namespaces in Imports field not imported from:\n    ‘callr’ ‘cli’ ‘R6’ ‘tibble’\n    All declared Imports should be used.\n\n0 errors ✔ | 0 warnings ✔ | 1 note ✖\n```\n\nThis is the expected result. I haven't gotten around to dealing with that note yet, so this is no different to what I'd get if I'd run it on ubuntu. The one part that is slightly different is this:\n\n```\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\nFailed to connect to bus: Host is down\nWarning: Your system is mis-configured: ‘/var/db/timezone/localtime’ is not a symlink\nWarning: ‘/var/db/timezone/localtime’ is not identical to any known timezone file\nWarning message:\nIn system(\"timedatectl\", intern = TRUE) :\n  running command 'timedatectl' had status 1\n```\n\nYeah. I deliberately didn't try to faff about with systemd in these images, so this is an expected warning. It's not a problem with queue or with arch, just a consequence of how I built the images. That would have some consequences for testing a lot of packages, but I'm not trying to recreate the rocker project here so I'm not too fussed about it in this little exercise.\n\nThe advantage to passing arguments is that you can build many images from the same dockerfile, and docker will reuse the cached layers intelligently. Even though I've never tried testing the praise package on arch before, this builds immediately and without downloading anything, because everything that actually matters was already done when I built the \"test-queue\" image earlier:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build \\\n  --tag test-praise \\\n  --build-arg user=rladies \\\n  --build-arg repo=praise \\\n  test-on-arch \n```\n:::\n\n\n```\nSending build context to Docker daemon  3.072kB\nStep 1/7 : FROM ghcr.io/djnavarro/arch-r:test\n ---> 549fdff95a53\nStep 2/7 : COPY clone-and-check.R /home/clone-and-check.R\n ---> Using cache\n ---> 90635e60ba89\nStep 3/7 : ARG user\n ---> Using cache\n ---> aaf0a7677e56\nStep 4/7 : ARG repo\n ---> Using cache\n ---> edfa009a9757\nStep 5/7 : ENV user=$user\n ---> Running in fee7736cc9b3\nRemoving intermediate container fee7736cc9b3\n ---> 4b17eb3a42ed\nStep 6/7 : ENV repo=$repo\n ---> Running in 6e7686a3cc31\nRemoving intermediate container 6e7686a3cc31\n ---> 5182d4b98223\nStep 7/7 : CMD Rscript /home/clone-and-check.R\n ---> Running in 1caac213f8b0\nRemoving intermediate container 1caac213f8b0\n ---> 2a6dc9df46f4\nSuccessfully built 2a6dc9df46f4\nSuccessfully tagged test-praise:latest\n```\n\nIt's verbose, but fast, and it hasn't wasted anything by creating unnecessary copies. Let's run it:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker run test-praise\n```\n:::\n\n\n```\nTransferred 431 of 431 objects...done!\nChecked out 26 of 26 commits... done!\n\n── R CMD build ─────────────────────────────────────────────────────────────────\n* checking for file ‘.../DESCRIPTION’ ... OK\n* preparing ‘praise’:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nOmitted ‘LazyData’ from DESCRIPTION\n* building ‘praise_1.0.0.tar.gz’\n\n── R CMD check ─────────────────────────────────────────────────────────────────\n* using log directory ‘/tmp/Rtmpi7Ngun/file12ad64a83/praise.Rcheck’\n* using R version 4.2.2 (2022-10-31)\n* using platform: x86_64-pc-linux-gnu (64-bit)\n* using session charset: UTF-8\n* checking for file ‘praise/DESCRIPTION’ ... OK\n* this is package ‘praise’ version ‘1.0.0’\n* checking package namespace information ... OK\n* checking package dependencies ... OK\n* checking if this is a source package ... OK\n* checking if there is a namespace ... OK\n* checking for executable files ... OK\n* checking for hidden files and directories ... OK\n* checking for portable file names ... OK\n* checking for sufficient/correct file permissions ... OK\n* checking whether package ‘praise’ can be installed ... OK\n* checking installed package size ... OK\n* checking package directory ... OK\n* checking DESCRIPTION meta-information ... OK\n* checking top-level files ... OK\n* checking for left-over files ... OK\n* checking index information ... OK\n* checking package subdirectories ... OK\n* checking R files for non-ASCII characters ... OK\n* checking R files for syntax errors ... OK\n* checking whether the package can be loaded ... OK\n* checking whether the package can be loaded with stated dependencies ... OK\n* checking whether the package can be unloaded cleanly ... OK\n* checking whether the namespace can be loaded with stated dependencies ... OK\n* checking whether the namespace can be unloaded cleanly ... OK\n* checking dependencies in R code ... OK\n* checking S3 generic/method consistency ... OK\n* checking replacement functions ... OK\n* checking foreign function calls ... OK\n* checking R code for possible problems ... OK\n* checking Rd files ... OK\n* checking Rd metadata ... OK\n* checking Rd cross-references ... OK\n* checking for missing documentation entries ... OK\n* checking for code/documentation mismatches ... OK\n* checking Rd \\usage sections ... OK\n* checking Rd contents ... OK\n* checking for unstated dependencies in examples ... OK\n* checking examples ... OK\n* checking for unstated dependencies in ‘tests’ ... OK\n* checking tests ...\n  Running ‘testthat.R’\n OK\n* checking PDF version of manual ... OK\n* DONE\n\nStatus: OK\n\nSystem has not been booted with systemd as init system (PID 1). Can't operate.\nFailed to connect to bus: Host is down\nWarning: Your system is mis-configured: ‘/var/db/timezone/localtime’ is not a symlink\nWarning: ‘/var/db/timezone/localtime’ is not identical to any known timezone file\nWarning message:\nIn system(\"timedatectl\", intern = TRUE) :\n  running command 'timedatectl' had status 1\n── R CMD check results ─────────────────────────────────────── praise 1.0.0 ────\nDuration: 25.1s\n\n0 errors ✔ | 0 warnings ✔ | 0 notes ✔\n```\n\nOnce again we see the warning about systemd, and once again I am ignoring it.\n\nWe'll do one more. What about ggplot2? That has extra dependencies that aren't included in the test image. Let's see...\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker build \\\n  --tag test-ggplot2 \\\n  --build-arg user=tidyverse \\\n  --build-arg repo=ggplot2 \\\n  test-on-arch \n```\n:::\n\n\nI'll skip the output this time because it's not interesting. Now let's run it and...\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ndocker run test-ggplot2 \n```\n:::\n\n```\nTransferred 15676 of 74694 objects...\n```\n\n...uh, right. Look this is going to take a while so maybe we should move on? \n\nThe main reason I wanted to point to this is to highlight that this part is happening at run time: we're always downloading a fresh copy of the repository to run the tests. That makes sense in some context, but not others. The design choices I made in designing this docker image aren't the same ones I'd make if I was trying to design something that would work for a larger project.^[I mean, you could certainly write something similar as part of a containerised workflow on github actions that works similarly to existing workflows for R CMD check but executed within a container running arch. That doesn't seem out of the question, but this isn't the way you'd set it up!] It's a toy, nothing more!^[I know the mystery will be too much so I'd better resolve it: no, it didn't pass on the arch image. Some of the dependencies didn't install properly, and then eventually it threw an error trying to build the vignettes.]\n\n\n::: {.cell .column-screen-inset layout-align=\"center\" fig.dpi='200'}\n::: {.cell-output-display}\n![](index_files/figure-html/whale-row-3-1.png){fig-align='center' width=1536}\n:::\n:::\n\n\n\n## Hosting images\n\nFor the third example, let's look at the [`ghcr.io/djnavarro/arch-r:base`](https://github.com/djnavarro/arch-r/tree/base) image. In addition to the dockerfile there are two small text files used to specify locale information. The two locale files aren't very interesting and could easily have been included as strings in the dockerfile, but I found it neater to keep them separate. The `locale-gen` file specifies locales that the image understands, and `locale.conf` specifies configuration details. (Both are configuration files on linux). In any case, here's the whole thing:\n\n\n::: {.cell filename='ghcr.io/djnavarro/arch-r:base Dockerfile'}\n\n```{.dockerfile .cell-code}\n# Base image is Arch linux with the base-devel group installed\nFROM archlinux:base-devel\n\n# Labels provide metadata for the image\nLABEL org.opencontainers.image.source \"https://github.com/djnavarro/arch-r-base\" \nLABEL org.opencontainers.image.authors \"Danielle Navarro <djnavarro@protonmail.com>\" \nLABEL org.opencontainers.image.description DESCRIPTION\nLABEL org.opencontainers.image.licenses \"GPL-3.0\"\n\n# Set the locale\nCOPY locale.gen /etc/locale.gen\nCOPY locale.conf /etc/locale.conf\nRUN locale-gen\nENV LANG=en_US.UTF-8\nENV LC_ALL=en_US.UTF-8\n\n# Install R\nRUN pacman -Syu --noconfirm r\n\n# Default command: just start R\nCMD R --no-save\n```\n:::\n\n::: {.cell filename='ghcr.io/djnavarro/arch-r:base locale.gen'}\n\n```{.bash .cell-code}\nC.UTF8 UTF-8\nen_US.UTF-8 UTF-8\n```\n:::\n\n::: {.cell filename='ghcr.io/djnavarro/arch-r:base locale.conf'}\n\n```{.bash .cell-code}\nLANG=en_US.UTF-8\nLC_ALL=en_US.UTF-8\n```\n:::\n\n\nTruly exciting. \n\n\n::: {.cell .column-margin}\n::: {.cell-output-display}\n![Again, I need something more interesting than this](index_files/figure-html/whale-3-1.png){width=672}\n:::\n:::\n\n\nThese files are stored in the base branch of the github repo: [github.com/djnavarro/arch-r/tree/base](https://github.com/djnavarro/arch-r/tree/base). As you might have guessed, the source files for the test image are in the test branch. I'm not in any way an expert on github actions, but I do know a little bit. Just enough to be dangerous, I expect. Here's the [workflow](https://github.com/djnavarro/arch-r/blob/main/.github/workflows/publish-docker-image.yaml) I'm using:\n\n\n::: {.cell filename='publish-docker-image.yaml'}\n\n```{.yaml .cell-code}\nname: publish-docker-image\n\non:\n  push:\n    branches: ['base', 'test']\n    \nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: checkout-repository\n        uses: actions/checkout@v3\n        \n      - name: login-container-registry\n        uses: docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n        \n      - name: extract-docker-metadata\n        id: meta\n        uses: docker/metadata-action@98669ae865ea3cffbcbaa878cf57c20bbf1c6c38\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n        \n      - name: build-and-push\n        uses: docker/build-push-action@ad44023a93711e3deb337508980b4b5e9bcdc5dc\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n```\n:::\n\n\nFor this workflow to run, I needed to edit the permissions associated with my github PAT to include some additional scopes. If, like me, you've created your PAT using the default scopes provided by `usethis::create_github_token()`, you'll need a few more to run workflows that build and modify docker images:\n\n- `read:packages` scope to download container images and read metadata.\n- `write:packages` scope to download and upload container images and read and write metadata.\n- `delete:packages` scope to delete container images.\n\nThis workflow triggers an automatic deployment to the github container registry whenever there is a new push to the base or test branches. This is what creates the `ghcr.io/djnavarro/arch-r:base` and `ghcr.io/djnavarro/arch-r:test` images. It's not as  sophisticated workflows used by the rocker project -- you can browse [github.com/rocker-org/rocker](https://github.com/rocker-org/rocker) if you want to see a nicer set up -- but it does work, and that was my main goal for this post.\n\n\n\n::: {.cell .column-screen-inset layout-align=\"center\" fig.dpi='200'}\n::: {.cell-output-display}\n![](index_files/figure-html/whale-row-4-1.png){fig-align='center' width=1536}\n:::\n:::\n\n\n## Resources\n\n- The docker reference documentation: [docs.docker.com/reference](https://docs.docker.com/reference/)\n\n- Instructions on giving docker sudo privileges for linux users: [docs.docker.com/engine/install/linux-postinstall](https://docs.docker.com/engine/install/linux-postinstall/)\n\n- The rocker project by Carl Boettiger, Dirk Eddelbuettel, Noam Ross, and Shima Tatsuya: [rocker-project.org](https://rocker-project.org/)\n\n- Source code for the rocker repositories: [github.com/rocker-org/rocker](https://github.com/rocker-org/rocker)\n\n- Blog post on docker by Colin Fay: [colinfay.me/docker-r-reproducibility](https://colinfay.me/docker-r-reproducibility/)\n\n- Slides on docker by Noam Ross: [github.com/noamross/nyhackr-docker-talk](https://github.com/noamross/nyhackr-docker-talk)\n\n- Docker for beginners by Prakhar Srivastav: [docker-curriculum.com](https://docker-curriculum.com/)\n\n- Working with the github container registry:\n[docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry)\n\n\n## Postscript: Making \"dockerplots\" in ggplot2\n\nI had a lot of fun making the whales. They're cute, and they make me happy. The function that generates these is called `sample_whales()`, and you can find the source code by expanding the folded code block below. Enjoy!\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Source code for `sample_whales()`\"}\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(dplyr)\n\nsample_whales <- function(seed = NULL, nrow = 4, ncol = 6) {\n\n  if(is.null(seed)) seed <- sample(1000, 1)\n  set.seed(seed)\n\n  nwhales <- nrow * ncol\n\n  # define a circle\n  circle <- tibble(\n    th = seq(0, 2*pi, length.out = 1000),\n    x = cos(th),\n    y = sin(th)\n  )\n\n  # distort a circle to create the whale body\n  whale_body <- circle |>\n    mutate(\n      y = if_else(y > 0, 0, y),\n      y = if_else(x < 0, -abs(y) ^ .6, -abs(y) ^ 1.7)\n    )\n\n  # distort a circle to create the whale tail\n  whale_tail <- circle |>\n    mutate(\n      weight = (abs(th - pi)/pi) ^ 1.3,\n      angle = pi * 1.2,\n      x = x * weight + .35 * (1 - weight),\n      x_scaled = x * .6,\n      y_scaled = y * .4,\n      x = x_scaled * cos(angle) - y_scaled * sin(angle),\n      y = x_scaled * sin(angle) + y_scaled * cos(angle),\n      x = x + 1.35,\n      y = y + 0.25\n    )\n\n  # bind the body to the tail to make a whale\n  whale <- bind_rows(whale_body, whale_tail)\n\n  # fully stacked set of boxes\n  box_stack <- expand_grid(\n    x = seq(-.7, .5, .3),\n    y = seq(.25, 1.5, .3)\n  )\n\n  # sample names using babynames package\n  names <- unique(sample(\n    x = babynames::babynames$name,\n    size = ceiling(nwhales * 1.2)\n  ))\n\n  # sample colours using a blue palette from ggthemes\n  shades <- sample(\n    x = ggthemes::canva_palettes$`Cool blues`,\n    size = nrow * ncol,\n    replace = TRUE\n  )\n\n  boxes <- list()\n  whales <- list()\n  for(i in 1:(nrow * ncol)) {\n\n    # assign the whales a name and a look\n    whales[[i]] <- whale |>\n      mutate(\n        name = names[[i]],\n        look = shades[[i]]\n      )\n\n    # assign the whales a name and colour,\n    # and randomly remove boxes off the stack\n    boxes[[i]] <- box_stack |>\n      mutate(\n        name = names[[i]],\n        look = shades[[i]]\n      ) |>\n      group_by(x) |>\n      mutate(max_height = runif(1, min = .05, max = 1.8)) |>\n      filter(y < max_height)\n  }\n\n  # collapse lists to data frames\n  boxes <- bind_rows(boxes)\n  whales <- bind_rows(whales)\n\n  # last minute tinkering... :-)\n  boxes <- boxes |> mutate(y = y - .3, x = x + .01)\n  whales <- whales |> mutate(y = y - .31)\n\n  # draw the plot\n  ggplot(mapping = aes(x, y, fill = look, colour = look)) +\n    geom_polygon(data = whales, linewidth = 2) +\n    geom_tile(\n      data = boxes,\n      width = .18,\n      height = .18,\n      linewidth = 2,\n      linejoin = \"bevel\"\n    ) +\n    facet_wrap(vars(name), nrow = nrow, ncol = ncol) +\n    coord_equal(xlim = c(-1.5, 1.5), ylim = c(-1.5, 1.5)) +\n    scale_x_continuous(labels = NULL, name = NULL) +\n    scale_y_continuous(labels = NULL, name = NULL) +\n    scale_fill_identity() +\n    scale_color_identity() +\n    theme_minimal(base_size = 14) +\n    theme(\n      axis.ticks = element_blank(),\n      panel.border = element_rect(fill = NA, colour = \"grey90\")\n    )\n}\n```\n:::\n\n::: {.cell .column-screen-inset layout-align=\"center\" fig.dpi='200'}\n::: {.cell-output-display}\n![](index_files/figure-html/whale-grid-1.png){fig-align='center' width=1536}\n:::\n:::\n\n\n\n<!--------------- appendices go here ----------------->\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}