<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Danielle Navarro">
<meta name="dcterms.date" content="2023-05-31">
<meta name="description" content="A book review, sort of. Not really. Look, Greg sent me a copy and I had fun reading it. okay?">

<title>Notes from a data witch - Software design by example</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background: #eeeeee;
      }
</style>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Notes from a data witch - Software design by example">
<meta property="og:description" content="A book review, sort of. Not really. Look, Greg sent me a copy and I had fun reading it. okay?">
<meta property="og:image" content="https://blog.djnavarro.net/posts/2023-05-31_software-design-by-example/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==">
<meta property="og:site_name" content="Notes from a data witch">
<meta name="twitter:title" content="Notes from a data witch - Software design by example">
<meta name="twitter:description" content="A book review, sort of. Not really. Look, Greg sent me a copy and I had fun reading it. okay?">
<meta name="twitter:image" content="https://blog.djnavarro.net/posts/2023-05-31_software-design-by-example/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==">
<meta name="twitter:creator" content="@djnavarro">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.xml"> 
<span class="menu-text">RSS</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-sites" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Sites</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-sites">    
        <li>
    <a class="dropdown-item" href="https://djnavarro.net">
 <span class="dropdown-text">Homepage</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://blog.djnavarro.net">
 <span class="dropdown-text">Data science blog</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://art.djnavarro.net">
 <span class="dropdown-text">Generative art</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://papers.djnavarro.net">
 <span class="dropdown-text">Academic papers</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://djnavarro.net/sites">
 <span class="dropdown-text">More…</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Software design by example</h1>
                  <div>
        <div class="description">
          A book review, sort of. Not really. Look, Greg sent me a copy and I had fun reading it. okay?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Software Design</div>
                <div class="quarto-category">Javascript</div>
                <div class="quarto-category">R</div>
                <div class="quarto-category">Regular Expressions</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://djnavarro.net">Danielle Navarro</a> <a href="https://orcid.org/0000-0001-7648-6578" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 31, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#who-is-the-book-for" id="toc-who-is-the-book-for" class="nav-link active" data-scroll-target="#who-is-the-book-for">Who is the book for?</a></li>
  <li><a href="#rewarding-the-cursory-reader" id="toc-rewarding-the-cursory-reader" class="nav-link" data-scroll-target="#rewarding-the-cursory-reader">Rewarding the cursory reader</a></li>
  <li><a href="#a-worked-example" id="toc-a-worked-example" class="nav-link" data-scroll-target="#a-worked-example">A worked example</a></li>
  <li><a href="#writing-the-tokenizer" id="toc-writing-the-tokenizer" class="nav-link" data-scroll-target="#writing-the-tokenizer">Writing the tokenizer</a>
  <ul class="collapse">
  <li><a href="#preliminaries" id="toc-preliminaries" class="nav-link" data-scroll-target="#preliminaries">Preliminaries</a></li>
  <li><a href="#version-1" id="toc-version-1" class="nav-link" data-scroll-target="#version-1">Version 1</a></li>
  <li><a href="#version-2" id="toc-version-2" class="nav-link" data-scroll-target="#version-2">Version 2</a></li>
  <li><a href="#post-mortem" id="toc-post-mortem" class="nav-link" data-scroll-target="#post-mortem">Post-mortem</a></li>
  </ul></li>
  <li><a href="#parsing-the-tokens" id="toc-parsing-the-tokens" class="nav-link" data-scroll-target="#parsing-the-tokens">Parsing the tokens</a>
  <ul class="collapse">
  <li><a href="#preliminaries-1" id="toc-preliminaries-1" class="nav-link" data-scroll-target="#preliminaries-1">Preliminaries</a></li>
  <li><a href="#version-1-1" id="toc-version-1-1" class="nav-link" data-scroll-target="#version-1-1">Version 1</a></li>
  <li><a href="#version-2-1" id="toc-version-2-1" class="nav-link" data-scroll-target="#version-2-1">Version 2</a></li>
  </ul></li>
  <li><a href="#final-thoughts" id="toc-final-thoughts" class="nav-link" data-scroll-target="#final-thoughts">Final thoughts?</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<!--------------- my typical setup ----------------->
<!--------------- post begins here ----------------->
<p>The book I’m currently reading is <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-JavaScript/Wilson/p/book/9781032330235">Software Design by Example: A Tool-Based Introduction with JavaScript</a> by <a href="https://third-bit.com/">Greg Wilson</a>. Greg was kind enough to send me a review copy a little while back, and I’ve been slowly working my way through it.</p>
<p>In some ways I’m not the target audience for the book: it’s a book about software engineering that uses JavaScript for the worked examples, not a book designed to teach you JavaScript. I’m not the worst JavaScript coder in the world, but I’m not the strongest either, so it’s harder work for me than maybe it would have been if JavaScript were my primary language.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="cover.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" alt="Book cover for 'Software Design by Example'"></p>
</figure>
</div>
<section id="who-is-the-book-for" class="level2">
<h2 class="anchored" data-anchor-id="who-is-the-book-for">Who is the book for?</h2>
<p>Some years ago I took a very good course that Greg ran on how to teach technical concepts,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and one thing he emphasised in that course is the importance of designing teaching materials with <em>specific</em> learning personas in mind. Having a small number of representative examples in mind when you write the content is incredibly useful when teaching, so it is no surprise that – literally on page 1 – the book states explicitly what the learner personas used to write the book were.</p>
<p>I’m going to reproduce them in full in this blog post as a reminder to myself that this is the right way to construct learner personas.</p>
<blockquote class="blockquote">
<div class="line-block"></div>
<ul>
<li>Aïsha started writing VB macros for Excel in an accounting course and never looked back. After spending three years doing front-end JavaScript work she now wants to learn how to build back-end applications. This material will fill in some gaps in her programming knowledge and teach her some common design patterns</li>
<li>Rupinder is studying computer science at college. He has learned a lot about the theory of algorithms, and while he uses Git and unit testing tools in his assignments, he doesn’t feel he understands how they work. This material will give him a better understanding of these tools and how to design new ones.</li>
<li>Yim builds mobile apps for a living but also teaches two college courses: one on full-stack web development using JavaScript and Node and another titled “Software Design”. They are happy with the former, but frustrated that so many books about the latter subject talk about it in the abstract and use examples that their students can’t relat to. This material will fill those gaps and give them starting points for a wide variety of course assignments.</li>
</ul>
</blockquote>
<p>They’re detailed enough to make the teacher engage with the personas during the writing process, diverse enough to help catch things the writer might not have thought of, and provide a <em>strong</em> indication to the learner about whether the book is written for them. In my case, for instance, it’s pretty clear from the outset that I’m likely to struggle with the level of JavaScript involved. Indeed, when I look at the list of skills that the reader is expected to have (on pages 1-2) I’m fine on most things but I suspect I have a little less practical experience with JavaScript than is ideal for a reader of this book. I’m not terrible at it, I just don’t spend enough time with it to feel fluent.</p>
<p>That’s okay, of course. It’s often a good experience as a learner to read content that pushes you outside your comfort zone. What matters is that you <em>know in advance</em> which aspects are going to be hard work for you. Thankfully, <em>Software Design by Example</em> does that very well at the beginning.</p>
</section>
<section id="rewarding-the-cursory-reader" class="level2">
<h2 class="anchored" data-anchor-id="rewarding-the-cursory-reader">Rewarding the cursory reader</h2>
<p>Despite knowing from the outset that I’m ever-so-slightly outside the target audience for the book, I’m still finding it very rewarding. To understand why, it’s worth taking a moment to look at how the book uses the glossary as the end to help readers like myself who have never received a formal education in programming… I’m basically the Aïsha persona, except with R playing the same role for me that JavaScript plays for her.</p>
<p>Because I don’t have a formal background and – to put it gently – don’t belong to a demographic that can easily acquire the “culture” of software engineering, I very commonly have the experience in conversation that software engineers will use terms that they simply assume that “everybody knows”, and never take the time to explain them. The actual concepts are often very simple things, and often I’ve had experience with them without knowing the names, but no-one ever tells you what the words mean and – sadly – many people in the field have a tendency to make you feel like an idiot if you ask.</p>
<p>With that as the real world backdrop, I’m finding the glossary to be worth its weight in gold. Here’s a little snippet from the top of page 318:</p>
<blockquote class="blockquote">
<div class="line-block"></div>
<ul>
<li><strong>query string</strong>. The portion of a <strong>URL</strong> after the question mark ? that specfies extra parameters for the <strong>HTTP request</strong> as name-value pairs</li>
<li><strong>race condition</strong>. A situation in which a result depend on the order in which two or more concurrent operations are carried out.</li>
<li><strong>raise (an exception)</strong>. To signal that something unexpected or unusual has happened in a program by creating an <strong>exception</strong> and handling it to the <strong>error-handling</strong> system, which then tries to find a point in the program that will <strong>catch</strong> it.</li>
<li><strong>read-eval-print-loop (REPL)</strong>. An interactive program that reads a command typed in by a user, executes it, prints the result, and then waits patiently for the next command. REPLs are often used to explore new ideas, or for debugging.</li>
</ul>
</blockquote>
<p>I can honestly say that at no point in my life has someone explained to me what a <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a> is or what a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> actually is. Seriously. I’ve worked in tech companies and people use those terms all the time but they never explain them. Very frustrating. So when I read entries like this in the glossary I find myself going “oh, <em>that’s</em> what <blah> means… okay, yes, I did already know this… but now I know what the name for it is”. I mean, race conditions are not at all unfamiliar to me – I encounter them quite a bit – but because software engineers have a tendency to refer to “race conditions” without ever saying what the term means, I’ve sat in a lot of very confusing conversations over the years that would have made a lot more bloody sense had I known the nomenclature or been in a position to “just ask” without being made to feel stupid.</blah></p>
<p>I think that’s likely to be true for a lot of self-taught programmers who never studied computer science, but instead had to learn to code in order to solve practical problems. The mere act of reading a concise definition of each thing has the effect of making my mental model more precise, and better aligned with the mental models that other people in the field adopt. It’s a helpful way to learn the culture and avoid getting caught out by the various <a href="https://en.wikipedia.org/wiki/Shibboleth">shibboleths</a> that are sadly pervasive the tech industry.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>There are other examples of this sort of thing throughout the book, historical anecdotes and other tidbits that make it a little easier for an outsider to make sense of the culture of software engineering. As an example, this little passage on page 145 makes sense of something I’ve never understood:</p>
<blockquote class="blockquote">
<p>The coordinate systems for screens puts (0, 0) in the upper left corner instead of the lower left. X increases to the right as usual, but Y increases as we go down, rather than up [The book has a little picture here]. This convention is a holdover from the days of teletype terminals that printed lines on rolls of paper</p>
</blockquote>
<p>These historical asides are really valuable. It feels a little bit like one of those “Magician’s Secrets Revealed!” shows. Knowing the terminology, conventions, and history behind a thing does so much of the work in making it all feel a bit more coherent.</p>
<p>Anyway, let’s dive a little deeper, shall we?</p>
</section>
<section id="a-worked-example" class="level2">
<h2 class="anchored" data-anchor-id="a-worked-example">A worked example</h2>
<blockquote class="blockquote">
<p>My mum always liked Delia Smith <br> And I drank, drank, drank just to deal with my shit <br> I learned to tell little white lies <br> When I feel inadequate almost all the time <br> <br> I’d like to think I’m deep <br> I’d like to think I’m deep <br> I’d like to think I’m deep <br> But I just skim the pages, so I can fake my speech <br> &nbsp; &nbsp; - <a href="https://youtu.be/zHHjDihVwiQ">Sprints</a></p>
</blockquote>
<p>A little honesty when writing blog posts is important, I feel. When reading the book I did not, in fact, attempt all the exercises or work through all the code examples. I tinkered with a few of the examples, read some parts thoroughly, and skimmed other parts. That’s pretty representative of how I read technical books, really. I’ll pick a few parts that I want to understand properly and do a deep dive in those sections, and read the rest of it in a much more superficial way.</p>
<p>The parts that I did read fairly deeply are Chapters 7 and 8, which talk about how to <a href="https://en.wikipedia.org/wiki/Parsing">parse</a> a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a>, and how to write the code that does <a href="https://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> using them. Actually, if I’m super honest the part I spent most time with is Chapter 8, which shows you how to extract <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Token">tokens</a> and a <a href="https://en.wikipedia.org/wiki/Parse_tree">parse tree</a> for a restricted form of regular expression syntax. For that chapter, I worked through the examples and translated (most of) the code in R. In the rest of the post I’ll show the code that I wrote, tie it back to the structure of Chapter 8 in the book, and at the end I’ll say a little about what I learned from this exercise.</p>
<p>The subset of regular expression syntax that the book uses for this chapter has the following rules:</p>
<table class="table">
<colgroup>
<col style="width: 16%">
<col style="width: 56%">
<col style="width: 26%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Token Kind</th>
<th style="text-align: left;">Meaning</th>
<th style="text-align: center;">Characters used</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Literal</td>
<td style="text-align: left;">A literal character</td>
<td style="text-align: center;"><code>a</code>, <code>b</code>, <code>c</code>, etc</td>
</tr>
<tr class="even">
<td style="text-align: left;">Start</td>
<td style="text-align: left;">Beginning of string</td>
<td style="text-align: center;"><code>^</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">End</td>
<td style="text-align: left;">End of string</td>
<td style="text-align: center;"><code>$</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Any</td>
<td style="text-align: left;">Zero or more of the previous thing</td>
<td style="text-align: center;"><code>*</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Or</td>
<td style="text-align: left;">Either the thing before or the thing after</td>
<td style="text-align: center;"><code>|</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Group</td>
<td style="text-align: left;">Collection of tokens to treat as one thing</td>
<td style="text-align: center;"><code>(</code> and <code>)</code></td>
</tr>
</tbody>
</table>
<p>It’s a very small subset of the regular expression grammar available for pattern matching in R, JavaScript, and pretty much every language these days, but it’s a handy one. It’s certainly rich enough to make it an interesting exercise to write a parser. Not that it’s particularly important to write my own parser: the purpose of doing so is to wrap my head around the basics of how parsers work and nothing more. As Greg helpfully reminds us on page 99, if a format is commonly known there will be good tools already, and if you find yourself wanting to roll your own parser to interpret some new file format you just invented for something… there’s a good chance you shouldn’t do it. The world has enough file formats already.</p>
</section>
<section id="writing-the-tokenizer" class="level2">
<h2 class="anchored" data-anchor-id="writing-the-tokenizer">Writing the tokenizer</h2>
<p>If you want to write a regular expression parser, or any other parser for that matter, you actually have two distinct but interrelated problems to solve. Your data takes the form of an input string that you need to process. In English text, an input string might look like <code>"Danielle hates regular expressions"</code> but in a regular expression you’re more likely to have something that looks like <code>"^caa*t$</code>. To interpret these strings – in a purely <a href="https://en.wikipedia.org/wiki/Syntax">syntactic</a> sense, not a <a href="https://en.wikipedia.org/wiki/Semantics">semantic</a> one – you need to</p>
<ul>
<li><p>Carve the string up into a sequence of distinct (and possibly labelled) <strong>tokens</strong>. My English expression could be divided into a sequence of four tokens corresponding to the four words: <code>"Danielle"</code>, <code>"hates"</code>, <code>"regular"</code>, <code>"expressions"</code>. This <strong>tokenization</strong> process is not uniquely defined. For instance, I might choose to acknowledge that the <code>"-s"</code> ending in some words is in fact a distinct unit. While this is absolutely not the post to talk about <a href="https://en.wikipedia.org/wiki/Inflection">inflexional morphology</a> in linguistics, it’s important to recognise that in some contexts you might want to tokenize my sentence as <code>"Danielle"</code>, <code>"hate"</code>, <code>"-s"</code>, <code>"regular"</code>, <code>"expression"</code>, <code>"-s"</code>.</p></li>
<li><p>Organise (or <strong>parse</strong>) the tokens into a structured format that explicitly acknowledges the way they relate to each other grammatically. For my English sentence this parsing might be something like this <code>[Danielle] [[hates] [regular expressions]]</code>, where I’m using the square brackets to illustrate the organisation: <code>"regular expressions"</code> and <code>"Danielle"</code> are both <a href="https://en.wikipedia.org/wiki/Noun_phrase">noun phrases</a>, <code>[hates]</code> is a verb, and <code>[hates regular expressions]</code> is a <a href="https://en.wikipedia.org/wiki/Verb_phrase">verb phrase</a>.</p></li>
</ul>
<p>The difference between the two is visually apparent when you try to draw them. When you tokenize the input you end up with a list of tokens:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Danielle
hates
regular
expressions</code></pre>
</div>
</div>
<p>After parsing this list of tokens, you end up with a tree. There’s lots of ways you could visualise this tree, but something like this is good enough for my purposes:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[
  Danielle
]
[
  [
    hates
  ]
  [
    regular
    expressions
  ]
]</code></pre>
</div>
</div>
<p>I could probably take this a bit further and annotate each part of the tree the way that linguists like to do, but it’s not necessary to get the basic idea.</p>
<p>The key thing to realise is that these two problems aren’t independent. If you tokenize the string in a way that isn’t suited to your problem, you’re going to make life harder when you try to write the parser. As it happens, <em>Software Design by Example</em> gives you a very gentle example of how this happens, which I’ll get to in moment when I try to write some code that automatically parses regular expressions like <code>^caa*t$</code>.</p>
<section id="preliminaries" class="level3">
<h3 class="anchored" data-anchor-id="preliminaries">Preliminaries</h3>
<p>In the book, all the examples are – obviously!!! – written in JavaScript, and my code is going to be written in R. This matters somewhat since R and JavaScript are different languages with different assumptions about how you write code.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> To make my life a little easier, I’m going to define some extremely informal R classes<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> that don’t actually do much. In my code, a “token” is just a list that has three fields: the <code>kind</code> of token referred to, the <code>loc</code> (location) of the token within the original string, and (optionally) a <code>value</code> that specifies the character (or characters) that represent the token in that string. Relatedly, the “token list” class is literally just a list:</p>
<div class="cell" data-file="token_class.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>token_class.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>token <span class="ot">&lt;-</span> <span class="cf">function</span>(kind, loc, <span class="at">value =</span> <span class="cn">NULL</span>) {</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="fu">structure</span>(</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="fu">list</span>(<span class="at">kind =</span> kind, <span class="at">loc =</span> loc, <span class="at">value =</span> value),</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="at">class =</span> <span class="st">"token"</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  )</span>
<span id="cb3-6"><a href="#cb3-6"></a>}</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a>token_list <span class="ot">&lt;-</span> <span class="cf">function</span>(...) {</span>
<span id="cb3-9"><a href="#cb3-9"></a>  <span class="fu">structure</span>(</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="fu">list</span>(...),</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="at">class =</span> <span class="st">"token_list"</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>  )</span>
<span id="cb3-13"><a href="#cb3-13"></a>}</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a>print.token <span class="ot">&lt;-</span> <span class="cf">function</span>(x, ...) {</span>
<span id="cb3-16"><a href="#cb3-16"></a>  <span class="fu">cat</span>(<span class="st">"&lt;Token at "</span>,  x<span class="sc">$</span>loc, <span class="st">"&gt; "</span>, x<span class="sc">$</span>kind, <span class="at">sep =</span> <span class="st">""</span>)</span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(x<span class="sc">$</span>value)) {</span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="fu">cat</span>(<span class="st">":"</span>, x<span class="sc">$</span>value)</span>
<span id="cb3-19"><a href="#cb3-19"></a>  }</span>
<span id="cb3-20"><a href="#cb3-20"></a>  <span class="fu">cat</span>(<span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb3-21"><a href="#cb3-21"></a>  <span class="fu">return</span>(<span class="fu">invisible</span>(x))</span>
<span id="cb3-22"><a href="#cb3-22"></a>}</span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a>print.token_list <span class="ot">&lt;-</span> <span class="cf">function</span>(x, ...) {</span>
<span id="cb3-25"><a href="#cb3-25"></a>  <span class="cf">if</span>(<span class="fu">length</span>(x) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="fu">cat</span>(<span class="st">"&lt;Empty token list&gt;</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb3-27"><a href="#cb3-27"></a>  } <span class="cf">else</span> {</span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="cf">for</span>(token <span class="cf">in</span> x) {</span>
<span id="cb3-29"><a href="#cb3-29"></a>      <span class="fu">print</span>(token)</span>
<span id="cb3-30"><a href="#cb3-30"></a>    }</span>
<span id="cb3-31"><a href="#cb3-31"></a>  }</span>
<span id="cb3-32"><a href="#cb3-32"></a>  <span class="fu">return</span>(<span class="fu">invisible</span>(x))</span>
<span id="cb3-33"><a href="#cb3-33"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>The reason I decided to write this code for this post is that it also defines <code>print()</code> methods for these objects that make the printed output a little prettier:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">token</span>(<span class="at">kind =</span> <span class="st">"Noun"</span>, <span class="at">loc =</span> <span class="dv">1</span>, <span class="at">value =</span> <span class="st">"Danielle"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Noun: Danielle</code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">token_list</span>(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">token</span>(<span class="at">kind =</span> <span class="st">"Noun"</span>, <span class="at">loc =</span> <span class="dv">1</span>, <span class="at">value =</span> <span class="st">"Danielle"</span>),</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">token</span>(<span class="at">kind =</span> <span class="st">"Verb"</span>, <span class="at">loc =</span> <span class="dv">10</span>, <span class="at">value =</span> <span class="st">"hates"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Noun: Danielle
&lt;Token at 10&gt; Verb: hates</code></pre>
</div>
</div>
<p>Without the print methods, you’d see each token printed as a list, and the list of tokens printed as a list of lists. It’s not super-important, but it does help me stay sane as I write. But whatever, let’s move on and start writing a tokenizer for (very restricted!) regular expressions…</p>
</section>
<section id="version-1" class="level3">
<h3 class="anchored" data-anchor-id="version-1">Version 1</h3>
<p>A hallmark of good teaching – in my not-entirely-humble opinion – is when the instructor designs material in a way that gently encourages the learner to discover things on your own. Chapter 8 of <em>Software Design by Example</em> does this rather nicely at the beginning, by having the reader start out by writing a simple tokenizer that is later revealed to be “readable, efficient, and wrong”. At the risk of revealing the instructional magic that Greg is so terribly good at, I’ll explicitly state the flawed intuition that might lead you to write a tokenizer like this.</p>
<p>Suppose I were to think about my tokenizer by considering a regular expression like <code>"^(cat)|(dog)$"</code>. There’s a real trap you can fall into here, because this regular expression has natural language words, and you might be tempted to write a tokenizer that treats <code>"cat"</code> and <code>"dog"</code> as tokens. Or, to be slightly more precise, you might decide that to create tokens that allow “Literals” to contain multiple characters, like this:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tokenize</span>(<span class="st">"^(cat|dog)$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Start
&lt;Token at 2&gt; GroupStart
&lt;Token at 3&gt; Literal: cat
&lt;Token at 6&gt; Or
&lt;Token at 7&gt; Literal: dog
&lt;Token at 10&gt; GroupEnd
&lt;Token at 11&gt; End</code></pre>
</div>
</div>
<p>Merging a sequence of literal characters into a single multi-character literal makes the output readable, and who doesn’t love it when the tokenizer informs you that you have a “Literal cat” in your string?</p>
<p>The book then walks you through the process of writing a <code>tokenize()</code> function that behaves exactly like this. Obviously, the original is in JavaScript, but here’s an R version:</p>
<div class="cell" data-file="tokenizer_1.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>tokenizer_1.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>simple <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="st">"*"</span> <span class="ot">=</span> <span class="st">"Any"</span>,</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="st">"|"</span> <span class="ot">=</span> <span class="st">"Or"</span>,</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="st">"("</span> <span class="ot">=</span> <span class="st">"GroupStart"</span>,</span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="st">")"</span> <span class="ot">=</span> <span class="st">"GroupEnd"</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>)</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>tokenize <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb10-9"><a href="#cb10-9"></a>  result <span class="ot">&lt;-</span> <span class="fu">token_list</span>()</span>
<span id="cb10-10"><a href="#cb10-10"></a>  n <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nchar</span>(text)) {</span>
<span id="cb10-12"><a href="#cb10-12"></a>    chr <span class="ot">&lt;-</span> <span class="fu">substr</span>(text, <span class="at">start =</span> i, <span class="at">stop =</span> i)</span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="co"># simple cases are always added as non-literal tokens</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="cf">if</span> (chr <span class="sc">%in%</span> <span class="fu">names</span>(simple)) {</span>
<span id="cb10-16"><a href="#cb10-16"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(simple[[chr]], i)</span>
<span id="cb10-17"><a href="#cb10-17"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="co"># the ^ character is non-literal if position is 1</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    } <span class="cf">else</span> <span class="cf">if</span> (chr <span class="sc">==</span> <span class="st">"^"</span> <span class="sc">&amp;</span> i <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb10-21"><a href="#cb10-21"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"Start"</span>, i)</span>
<span id="cb10-22"><a href="#cb10-22"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb10-23"><a href="#cb10-23"></a></span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="co"># the $ character is non-literal if it's the last character</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>    } <span class="cf">else</span> <span class="cf">if</span> (chr <span class="sc">==</span> <span class="st">"$"</span> <span class="sc">&amp;</span> i <span class="sc">==</span> <span class="fu">nchar</span>(text)) {</span>
<span id="cb10-26"><a href="#cb10-26"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"End"</span>, i)</span>
<span id="cb10-27"><a href="#cb10-27"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb10-28"><a href="#cb10-28"></a></span>
<span id="cb10-29"><a href="#cb10-29"></a>    <span class="co"># literals that follow a non-literal create a new token</span></span>
<span id="cb10-30"><a href="#cb10-30"></a>    } <span class="cf">else</span> <span class="cf">if</span> (n <span class="sc">&gt;</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> result[[n]]<span class="sc">$</span>kind <span class="sc">!=</span> <span class="st">"Literal"</span>){</span>
<span id="cb10-31"><a href="#cb10-31"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"Literal"</span>, i, <span class="at">value =</span> chr)</span>
<span id="cb10-32"><a href="#cb10-32"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb10-33"><a href="#cb10-33"></a></span>
<span id="cb10-34"><a href="#cb10-34"></a>    <span class="co"># literals that follow a literal are combined with it</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>    } <span class="cf">else</span> {</span>
<span id="cb10-36"><a href="#cb10-36"></a>      result[[n]]<span class="sc">$</span>value <span class="ot">&lt;-</span> <span class="fu">paste0</span>(result[[n]]<span class="sc">$</span>value, chr)</span>
<span id="cb10-37"><a href="#cb10-37"></a>    }</span>
<span id="cb10-38"><a href="#cb10-38"></a>  }</span>
<span id="cb10-39"><a href="#cb10-39"></a>  <span class="fu">return</span>(result)</span>
<span id="cb10-40"><a href="#cb10-40"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>I won’t recapitulate all the steps that go into writing code like this – read the book if you want to know things at this level of detail – but suffice it to say that if I were better at JavaScript I’d have found it very easy to follow.</p>
<p>The point that matters here is that the reader is being encouraged to consider what happens to you later if you tokenize the input this way. Merging a sequence of literal characters into a single multi-character literal makes the output readable, and <em>in this specific case</em> the token list is very convenient if I later wanted to write a regular expression matcher that builds on top of this tokenizer. Using the base R <code>grepl()</code> function, you can see which strings match <code>"^(cat|dog)$"</code> and which don’t:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">grepl</span>(<span class="st">"^(cat|dog)$"</span>, <span class="fu">c</span>(<span class="st">"cat"</span>, <span class="st">"dog"</span>, <span class="st">"dag"</span>, <span class="st">"ca"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE  TRUE FALSE FALSE</code></pre>
</div>
</div>
<p>If my tokenizer represents the literals in <code>^(cat|dog)$</code> as the two multicharacter literals <code>"cat"</code> and <code>"dog"</code> then – in this instance – it’s going to be easier for me to write a regex matcher that mirrors the behaviour of <code>grepl()</code>.</p>
<p>Very nice.</p>
<p>Unfortunately, once you start thinking about regular expressions more generally, there’s a big problem with this tokenizer. It’s trying to be clever, by grouping multiple literals together without considering how those literals will be used later on by the parser, and it ends up being too greedy sometimes. Consider the regular expression <code>"^caa*t$"</code>. This is a pattern that should match against <code>"cat"</code> and <code>"caaaaat"</code> but should not match <code>"caacaat"</code>, as illustrated below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">grepl</span>(<span class="st">"^caa*t$"</span>, <span class="fu">c</span>(<span class="st">"cat"</span>, <span class="st">"caaaaat"</span>, <span class="st">"caacaat"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  TRUE  TRUE FALSE</code></pre>
</div>
</div>
<p>However, let’s look at the tokens produced by our <code>tokenizer()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tokenize</span>(<span class="st">"^caa*t$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Start
&lt;Token at 2&gt; Literal: caa
&lt;Token at 5&gt; Any
&lt;Token at 6&gt; Literal: t
&lt;Token at 7&gt; End</code></pre>
</div>
</div>
<p>Yeah, we’re in big trouble here.</p>
<p>That’s the wrong way to tokenize this input: in this regular expression the <code>*</code> operator (i.e., the <code>Any</code> token in our token list) needs to be applied only to the preceding character, so it’s not correct to treat <code>"caa"</code> as a single literal string. To write a functioning parser on top of this tokenizer would be a nightmare, because the parser would need to inspect the internal contents of the tokens: in order to parse the <code>*</code> character (the <code>Any</code> token), it would need to grab the <code>Literal caa</code> token and split it into two parts, a prefix <code>"ca"</code> and a suffix <code>"a"</code>, because <code>*</code> applies only to the suffix.</p>
<p>What this is telling us is that we’ve chosen a poor tokenizing scheme. The book is quite gentle in leading the reader to this conclusion, but when you’re actually writing the code yourself you can’t avoid discovering it. If your parser has to break apart your tokens to organise the input, then really you should be rethinking the tokenizer.</p>
</section>
<section id="version-2" class="level3">
<h3 class="anchored" data-anchor-id="version-2">Version 2</h3>
<p>Okay so that doesn’t work. The second approach considered in the chapter simplifies the code a little and produces a token list where every literal character is treated as a distinct token. The code is only a minor modification of the previous version:</p>
<div class="cell" data-file="tokenizer_2.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>tokenizer_2.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>simple <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="st">"*"</span> <span class="ot">=</span> <span class="st">"Any"</span>,</span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="st">"|"</span> <span class="ot">=</span> <span class="st">"Or"</span>,</span>
<span id="cb17-4"><a href="#cb17-4"></a>  <span class="st">"("</span> <span class="ot">=</span> <span class="st">"GroupStart"</span>,</span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="st">")"</span> <span class="ot">=</span> <span class="st">"GroupEnd"</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>)</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>tokenize <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb17-9"><a href="#cb17-9"></a>  result <span class="ot">&lt;-</span> <span class="fu">token_list</span>()</span>
<span id="cb17-10"><a href="#cb17-10"></a>  n <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nchar</span>(text)) {</span>
<span id="cb17-12"><a href="#cb17-12"></a>    chr <span class="ot">&lt;-</span> <span class="fu">substr</span>(text, <span class="at">start =</span> i, <span class="at">stop =</span> i)</span>
<span id="cb17-13"><a href="#cb17-13"></a></span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="co"># simple cases are always added as non-literal tokens</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>    <span class="cf">if</span> (chr <span class="sc">%in%</span> <span class="fu">names</span>(simple)) {</span>
<span id="cb17-16"><a href="#cb17-16"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(simple[[chr]], i)</span>
<span id="cb17-17"><a href="#cb17-17"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb17-18"><a href="#cb17-18"></a></span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="co"># the ^ character is non-literal if position is 1</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>    } <span class="cf">else</span> <span class="cf">if</span> (chr <span class="sc">==</span> <span class="st">"^"</span> <span class="sc">&amp;</span> i <span class="sc">==</span> <span class="dv">1</span>) {</span>
<span id="cb17-21"><a href="#cb17-21"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"Start"</span>, i)</span>
<span id="cb17-22"><a href="#cb17-22"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb17-23"><a href="#cb17-23"></a></span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="co"># the $ character is non-literal if it's the last character</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>    } <span class="cf">else</span> <span class="cf">if</span> (chr <span class="sc">==</span> <span class="st">"$"</span> <span class="sc">&amp;</span> i <span class="sc">==</span> <span class="fu">nchar</span>(text)) {</span>
<span id="cb17-26"><a href="#cb17-26"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"End"</span>, i)</span>
<span id="cb17-27"><a href="#cb17-27"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb17-28"><a href="#cb17-28"></a></span>
<span id="cb17-29"><a href="#cb17-29"></a>    <span class="co"># literals always create a new token</span></span>
<span id="cb17-30"><a href="#cb17-30"></a>    } <span class="cf">else</span> {</span>
<span id="cb17-31"><a href="#cb17-31"></a>      result[[n <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">token</span>(<span class="st">"Literal"</span>, i, <span class="at">value =</span> chr)</span>
<span id="cb17-32"><a href="#cb17-32"></a>      n <span class="ot">&lt;-</span> n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb17-33"><a href="#cb17-33"></a>    }</span>
<span id="cb17-34"><a href="#cb17-34"></a>  }</span>
<span id="cb17-35"><a href="#cb17-35"></a>  <span class="fu">return</span>(result)</span>
<span id="cb17-36"><a href="#cb17-36"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Here’s the sort of output we get from this version of the tokenizer:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tokenize</span>(<span class="st">"^caa*t$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Start
&lt;Token at 2&gt; Literal: c
&lt;Token at 3&gt; Literal: a
&lt;Token at 4&gt; Literal: a
&lt;Token at 5&gt; Any
&lt;Token at 6&gt; Literal: t
&lt;Token at 7&gt; End</code></pre>
</div>
</div>
<p>This output is entirely correct, as long as our goal is <em>only</em> to extract and label the tokens in our regular expression. The output correctly labels each literal as a literal and assigns the appropriate label to the non-literals. What is very clear, though, when you look at the output from this version of <code>tokenize()</code> is that it is absolutely <em>not</em> a parser. We’ve lost the grouping structure that we had in our original version. The tokenizer has no way of expressing the idea that <code>"ca"</code> is a syntactically coherent unit in the expression <code>^caa*t$</code>, or that <code>"cat"</code> is similarly coherent within <code>^(cat|dog)$</code>. It’s a good tokenizer, but a bad parser.</p>
<p>That’s okay: it’s not meant to be a parser. The tokenizer does its job perfectly well, and importantly it provides output that a good parser can work with. It requires a little thought, but it’s going to work out okay because the tokenizer is reliable <em>as</em> a tokenizer. Each tool does one job and only that job: you don’t need your tokenizer to parse the syntax, and you don’t want your parser to mess around with the internal contents of the tokens.</p>
<p>Gosh… I wonder if that’s one of those software engineering principles?</p>
</section>
<section id="post-mortem" class="level3">
<h3 class="anchored" data-anchor-id="post-mortem">Post-mortem</h3>
<p>At this point any competent software engineer is probably screaming internally, because I have not written any unit tests for my code. This is terribly bad practice, and something I would never do when writing actual software.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Suffice it to say <em>Software Design by Example</em> is at great pains to emphasize the importance of unit tests, and if you were actually following the chapter step by step you’d see that Greg does in fact introduce tests as he develops this example. I’ve been lazy in this blog post because… well, it’s a blog post. It’s neither intended to be software nor a chapter in a book on software engineering.</p>
<p>Anyway… let’s return to the development of ideas in the chapter, yes?</p>
</section>
</section>
<section id="parsing-the-tokens" class="level2">
<h2 class="anchored" data-anchor-id="parsing-the-tokens">Parsing the tokens</h2>
<p>The second half of chapter 8 in <em>Software Design by Example</em> focuses on the parser, and again I’m not going to try to recapitulate all the logic that the book walks you through. It takes the reader through an intuitive process of thinking about how you want to write the parser, but the key thing I want to highlight is that when you’re reading the book you get a strong sense of why you want to write the parser in two parts: there’s a “forward pass” where the parser sweeps through the token list from first to last, constructing the parts of the parse tree that it can handle on the basis of what it has seen so far, and then a subsequent clean up phase where it sweeps back and fixes all the incomplete parts. When I came to implement it in R myself I made some small departures from the way Greg has done it in the book, but the essence is the same. What I’ll do here is present two versions of the parser, one that <em>only</em> does the forward pass (so you can see all the missing bits), and then a second version that does the clean up afterwards.</p>
<section id="preliminaries-1" class="level3">
<h3 class="anchored" data-anchor-id="preliminaries-1">Preliminaries</h3>
<p>As before, I’ll do some preliminary work that isn’t really essential for the purposes of the book, but I find helpful for writing this blog post. Specifically, I’ll define a <code>subtree()</code> function that provides a “subtree” class. All it does is capture the fundamental structure of a tree: each node is defined by a <code>parent</code> element, and that parent can have zero, one, or more <code>children</code>. This isn’t really necessary for our parser, but it does allow me to define a <code>print()</code> method that makes the parse trees in this post look a little prettier:</p>
<div class="cell" data-file="parse_class.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>parse_class.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>subtree <span class="ot">&lt;-</span> <span class="cf">function</span>(parent, <span class="at">children =</span> <span class="fu">list</span>()) {</span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="fu">structure</span>(</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="fu">list</span>(<span class="at">parent =</span> parent, <span class="at">children =</span> children),</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="at">class =</span> <span class="st">"subtree"</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>  )</span>
<span id="cb20-6"><a href="#cb20-6"></a>}</span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a>print.subtree <span class="ot">&lt;-</span> <span class="cf">function</span>(x, ...) {</span>
<span id="cb20-9"><a href="#cb20-9"></a>  <span class="cf">if</span>(<span class="fu">length</span>(x) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="fu">cat</span>(<span class="st">"&lt;Empty parse_tree&gt;</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb20-11"><a href="#cb20-11"></a>  } <span class="cf">else</span> {</span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="fu">print</span>(x<span class="sc">$</span>parent)</span>
<span id="cb20-13"><a href="#cb20-13"></a>    <span class="cf">if</span>(<span class="fu">length</span>(x<span class="sc">$</span>children) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb20-14"><a href="#cb20-14"></a>      <span class="cf">for</span>(child <span class="cf">in</span> x<span class="sc">$</span>children) {</span>
<span id="cb20-15"><a href="#cb20-15"></a>        out <span class="ot">&lt;-</span> <span class="fu">capture.output</span>(<span class="fu">print</span>(child))</span>
<span id="cb20-16"><a href="#cb20-16"></a>        out <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">"    "</span>, out)</span>
<span id="cb20-17"><a href="#cb20-17"></a>        <span class="fu">cat</span>(out, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb20-18"><a href="#cb20-18"></a>      }</span>
<span id="cb20-19"><a href="#cb20-19"></a>    }</span>
<span id="cb20-20"><a href="#cb20-20"></a>  }</span>
<span id="cb20-21"><a href="#cb20-21"></a>  <span class="fu">return</span>(<span class="fu">invisible</span>(x))</span>
<span id="cb20-22"><a href="#cb20-22"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>Whatevs. That’s not really the point of the book, and frankly if I were writing a book on software design<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> I would probably make the same choice that Greg has made: for the blog post I want pretty output because it’s supposed to be an easy read. For a book that is intended to help you think about software design? For that you actually want the reader to engage deeply with the “list of lists of lists of…” data structure that my print methods are glossing over.</p>
</section>
<section id="version-1-1" class="level3">
<h3 class="anchored" data-anchor-id="version-1-1">Version 1</h3>
<p>With that out of the way, let’s have a look at the code for a parser that only does the forward sweep. The key insight that the book walks you through is that there are three distinct types of action the parser takes at this step:</p>
<ul>
<li>There are kinds of token (<code>Literal</code>, <code>Start</code>, <code>End</code>, and <code>GroupStart</code>) that the parser can process simply by appending the token to the bottom of the tree the moment it encounters them.</li>
<li>There are other kinds of token (<code>GroupEnd</code> and <code>Any</code>) that require the parser to restructure the tree, but they rely only on the tokens seen so far, so the parser can reorganise the tree on the fly during this first pass</li>
<li>There is one annoying token (<code>Or</code>) that depends both on things the parser has already seen <em>and</em> on things that haven’t been observed yet as the parser sweeps forward. What we do here is a partial organisation: we process the bits we know about (e.g., the <code>a</code> on the left hand side of an <code>a|b</code> statement is known even when we’ve only read <code>a|</code> so far) but then leave a “Missing” placeholder token to express the fact that we know that the <code>Or</code> operator <code>|</code> has two children: we know <code>a</code>, but <code>b</code> will need to be filled in later.</li>
</ul>
<p>Here’s the R code, which supplies an <code>update_tree()</code> function that sequentially modifes the parse tree whenever new tokens arrive:<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="cell" data-file="parser_1.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>parser_1.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>list_reverse <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb21-2"><a href="#cb21-2"></a>  x[<span class="fu">length</span>(x)<span class="sc">:</span><span class="dv">1</span>]</span>
<span id="cb21-3"><a href="#cb21-3"></a>}</span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>update_tree <span class="ot">&lt;-</span> <span class="cf">function</span>(tree, token) {</span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a>  <span class="co"># For some kinds of token, we simply append them to the tree</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>  <span class="cf">if</span>(token<span class="sc">$</span>kind <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Literal"</span>, <span class="st">"Start"</span>, <span class="st">"End"</span>, <span class="st">"GroupStart"</span>)) {</span>
<span id="cb21-9"><a href="#cb21-9"></a>    tree[[<span class="fu">length</span>(tree) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(token)</span>
<span id="cb21-10"><a href="#cb21-10"></a>  }</span>
<span id="cb21-11"><a href="#cb21-11"></a></span>
<span id="cb21-12"><a href="#cb21-12"></a>  <span class="co"># When GroupEnd is encountered, find the most recent GroupStart and</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>  <span class="co"># make the tokens between them the children of a Group</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"GroupEnd"</span>) {</span>
<span id="cb21-15"><a href="#cb21-15"></a>    children <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb21-16"><a href="#cb21-16"></a>    <span class="cf">while</span>(<span class="cn">TRUE</span>) {</span>
<span id="cb21-17"><a href="#cb21-17"></a>      last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb21-18"><a href="#cb21-18"></a>      tree <span class="ot">&lt;-</span> tree[<span class="sc">-</span><span class="fu">length</span>(tree)]</span>
<span id="cb21-19"><a href="#cb21-19"></a>      <span class="cf">if</span>(last<span class="sc">$</span>parent<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"GroupStart"</span>) {</span>
<span id="cb21-20"><a href="#cb21-20"></a>        <span class="cf">break</span></span>
<span id="cb21-21"><a href="#cb21-21"></a>      }</span>
<span id="cb21-22"><a href="#cb21-22"></a>      children[[<span class="fu">length</span>(children) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> last</span>
<span id="cb21-23"><a href="#cb21-23"></a>    }</span>
<span id="cb21-24"><a href="#cb21-24"></a>    tree[[<span class="fu">length</span>(tree) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb21-25"><a href="#cb21-25"></a>      <span class="at">parent =</span> <span class="fu">token</span>(<span class="st">"Group"</span>, last<span class="sc">$</span>parent<span class="sc">$</span>loc),</span>
<span id="cb21-26"><a href="#cb21-26"></a>      <span class="at">children =</span> <span class="fu">list_reverse</span>(children)</span>
<span id="cb21-27"><a href="#cb21-27"></a>    )</span>
<span id="cb21-28"><a href="#cb21-28"></a>  }</span>
<span id="cb21-29"><a href="#cb21-29"></a></span>
<span id="cb21-30"><a href="#cb21-30"></a>  <span class="co"># When Any is encountered, make the preceding token (or subtree)</span></span>
<span id="cb21-31"><a href="#cb21-31"></a>  <span class="co"># the child of the Any token</span></span>
<span id="cb21-32"><a href="#cb21-32"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"Any"</span>) {</span>
<span id="cb21-33"><a href="#cb21-33"></a>    last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb21-34"><a href="#cb21-34"></a>    tree[[<span class="fu">length</span>(tree)]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb21-35"><a href="#cb21-35"></a>      <span class="at">parent =</span> token,</span>
<span id="cb21-36"><a href="#cb21-36"></a>      <span class="at">children =</span> <span class="fu">list</span>(last)</span>
<span id="cb21-37"><a href="#cb21-37"></a>    )</span>
<span id="cb21-38"><a href="#cb21-38"></a>  }</span>
<span id="cb21-39"><a href="#cb21-39"></a></span>
<span id="cb21-40"><a href="#cb21-40"></a>  <span class="co"># When Or is encountered, create a subtree with two children. The</span></span>
<span id="cb21-41"><a href="#cb21-41"></a>  <span class="co"># first (or left) child is taken by moving it from the previous</span></span>
<span id="cb21-42"><a href="#cb21-42"></a>  <span class="co"># token/subtree in our list. The second child is tagged as "Missing"</span></span>
<span id="cb21-43"><a href="#cb21-43"></a>  <span class="co"># and will be filled in later</span></span>
<span id="cb21-44"><a href="#cb21-44"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"Or"</span>) {</span>
<span id="cb21-45"><a href="#cb21-45"></a>    last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb21-46"><a href="#cb21-46"></a>    tree[[<span class="fu">length</span>(tree)]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb21-47"><a href="#cb21-47"></a>      <span class="at">parent =</span> token,</span>
<span id="cb21-48"><a href="#cb21-48"></a>      <span class="at">children =</span> <span class="fu">list</span>(last, <span class="fu">subtree</span>(<span class="fu">token</span>(<span class="at">kind =</span> <span class="st">"Missing"</span>, <span class="at">loc =</span> <span class="dv">0</span>)))</span>
<span id="cb21-49"><a href="#cb21-49"></a>    )</span>
<span id="cb21-50"><a href="#cb21-50"></a>  }</span>
<span id="cb21-51"><a href="#cb21-51"></a></span>
<span id="cb21-52"><a href="#cb21-52"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb21-53"><a href="#cb21-53"></a>}</span>
<span id="cb21-54"><a href="#cb21-54"></a></span>
<span id="cb21-55"><a href="#cb21-55"></a>parse <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb21-56"><a href="#cb21-56"></a>  tree <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb21-57"><a href="#cb21-57"></a>  tokens <span class="ot">&lt;-</span> <span class="fu">tokenize</span>(text)</span>
<span id="cb21-58"><a href="#cb21-58"></a>  <span class="cf">for</span>(token <span class="cf">in</span> tokens) {</span>
<span id="cb21-59"><a href="#cb21-59"></a>    tree <span class="ot">&lt;-</span> <span class="fu">update_tree</span>(tree, token)</span>
<span id="cb21-60"><a href="#cb21-60"></a>  }</span>
<span id="cb21-61"><a href="#cb21-61"></a>  <span class="fu">class</span>(tree) <span class="ot">&lt;-</span> <span class="st">"token_list"</span> <span class="co"># allows pretty printing</span></span>
<span id="cb21-62"><a href="#cb21-62"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb21-63"><a href="#cb21-63"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For expressions like <code>"^caa*t$</code> that don’t have a <code>|</code>, this version of the parser constructs a completed parse tree:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"^caa*t$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Start
&lt;Token at 2&gt; Literal: c
&lt;Token at 3&gt; Literal: a
&lt;Token at 5&gt; Any
     &lt;Token at 4&gt; Literal: a
&lt;Token at 6&gt; Literal: t
&lt;Token at 7&gt; End</code></pre>
</div>
</div>
<p>Notice that the ordering of the tokens has changed: to represent the subexpression <code>a*</code>, the parser creates an <code>Any</code> token corresponding to the <code>*</code> character and ensures that the <code>Literal</code> <code>a</code> token is a child of the <code>Any</code> operator.</p>
<p>A similar thing happens where <code>GroupStart</code> and <code>GroupEnd</code> tokens are collapsed into a single <code>Group</code> token that has all tokens within the group as children:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"(na)* hey yeah goodbye"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 5&gt; Any
     &lt;Token at 1&gt; Group
          &lt;Token at 2&gt; Literal: n
          &lt;Token at 3&gt; Literal: a
&lt;Token at 6&gt; Literal:  
&lt;Token at 7&gt; Literal: h
&lt;Token at 8&gt; Literal: e
&lt;Token at 9&gt; Literal: y
&lt;Token at 10&gt; Literal:  
&lt;Token at 11&gt; Literal: y
&lt;Token at 12&gt; Literal: e
&lt;Token at 13&gt; Literal: a
&lt;Token at 14&gt; Literal: h
&lt;Token at 15&gt; Literal:  
&lt;Token at 16&gt; Literal: g
&lt;Token at 17&gt; Literal: o
&lt;Token at 18&gt; Literal: o
&lt;Token at 19&gt; Literal: d
&lt;Token at 20&gt; Literal: b
&lt;Token at 21&gt; Literal: y
&lt;Token at 22&gt; Literal: e</code></pre>
</div>
</div>
<p>For expressions that contain an either/or operation, we end up with a parse tree that contains one or more <code>Missing</code> tokens. That’s my way of expressing the fact that the parser needs to come back and clean up afterwards:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"(cat)|(dog)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 6&gt; Or
     &lt;Token at 1&gt; Group
          &lt;Token at 2&gt; Literal: c
          &lt;Token at 3&gt; Literal: a
          &lt;Token at 4&gt; Literal: t
     &lt;Token at 0&gt; Missing
&lt;Token at 7&gt; Group
     &lt;Token at 8&gt; Literal: d
     &lt;Token at 9&gt; Literal: o
     &lt;Token at 10&gt; Literal: g</code></pre>
</div>
</div>
<p>Notice that there are some kinds of regular expressions for which this clean-up might require us to dive deep into the tree to fix the incomplete parts:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"ab|((cd*)|ef)|g"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Literal: a
&lt;Token at 3&gt; Or
     &lt;Token at 2&gt; Literal: b
     &lt;Token at 0&gt; Missing
&lt;Token at 14&gt; Or
     &lt;Token at 4&gt; Group
          &lt;Token at 10&gt; Or
               &lt;Token at 5&gt; Group
                    &lt;Token at 6&gt; Literal: c
                    &lt;Token at 8&gt; Any
                         &lt;Token at 7&gt; Literal: d
               &lt;Token at 0&gt; Missing
          &lt;Token at 11&gt; Literal: e
          &lt;Token at 12&gt; Literal: f
     &lt;Token at 0&gt; Missing
&lt;Token at 15&gt; Literal: g</code></pre>
</div>
</div>
<p>Again, there’s a kind of principle here: each part of the tool has its own job to do. The forward pass does the parts that it can do, and delegates the unfinished work to the clean-up process. When reading the book, and especially when implementing it yourself, the learner is invited to think about the importance of carving up the software into sensible parts.</p>
<p>Seems like a thing worth knowing.</p>
</section>
<section id="version-2-1" class="level3">
<h3 class="anchored" data-anchor-id="version-2-1">Version 2</h3>
<p>At this point in the post I’m guessing that the reader is about ready to see the end product. The final version of the code adds a <code>compress_tree()</code> function that is called once the forward pass is complete. For simple trees all it really does is sweep up from bottom to top, but because there are regular expressions in which you can have <code>Or</code> tokens nested quite a long way into the parse tree it also sweeps up through the subtrees when they are encountered:</p>
<div class="cell" data-file="parser_2.R">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>parser_2.R</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1"></a>list_reverse <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb30-2"><a href="#cb30-2"></a>  x[<span class="fu">length</span>(x)<span class="sc">:</span><span class="dv">1</span>]</span>
<span id="cb30-3"><a href="#cb30-3"></a>}</span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a>update_tree <span class="ot">&lt;-</span> <span class="cf">function</span>(tree, token) {</span>
<span id="cb30-6"><a href="#cb30-6"></a></span>
<span id="cb30-7"><a href="#cb30-7"></a>  <span class="co"># For some kinds of token, we simply append them to the tree</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>  <span class="cf">if</span>(token<span class="sc">$</span>kind <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Literal"</span>, <span class="st">"Start"</span>, <span class="st">"End"</span>, <span class="st">"GroupStart"</span>)) {</span>
<span id="cb30-9"><a href="#cb30-9"></a>    tree[[<span class="fu">length</span>(tree) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(token)</span>
<span id="cb30-10"><a href="#cb30-10"></a>  }</span>
<span id="cb30-11"><a href="#cb30-11"></a></span>
<span id="cb30-12"><a href="#cb30-12"></a>  <span class="co"># When GroupEnd is encountered, find the most recent GroupStart and</span></span>
<span id="cb30-13"><a href="#cb30-13"></a>  <span class="co"># make the tokens between them the children of a Group</span></span>
<span id="cb30-14"><a href="#cb30-14"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"GroupEnd"</span>) {</span>
<span id="cb30-15"><a href="#cb30-15"></a>    children <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb30-16"><a href="#cb30-16"></a>    <span class="cf">while</span>(<span class="cn">TRUE</span>) {</span>
<span id="cb30-17"><a href="#cb30-17"></a>      last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb30-18"><a href="#cb30-18"></a>      tree <span class="ot">&lt;-</span> tree[<span class="sc">-</span><span class="fu">length</span>(tree)]</span>
<span id="cb30-19"><a href="#cb30-19"></a>      <span class="cf">if</span>(last<span class="sc">$</span>parent<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"GroupStart"</span>) {</span>
<span id="cb30-20"><a href="#cb30-20"></a>        <span class="cf">break</span></span>
<span id="cb30-21"><a href="#cb30-21"></a>      }</span>
<span id="cb30-22"><a href="#cb30-22"></a>      children[[<span class="fu">length</span>(children) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> last</span>
<span id="cb30-23"><a href="#cb30-23"></a>    }</span>
<span id="cb30-24"><a href="#cb30-24"></a>    tree[[<span class="fu">length</span>(tree) <span class="sc">+</span> <span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb30-25"><a href="#cb30-25"></a>      <span class="at">parent =</span> <span class="fu">token</span>(<span class="st">"Group"</span>, last<span class="sc">$</span>parent<span class="sc">$</span>loc),</span>
<span id="cb30-26"><a href="#cb30-26"></a>      <span class="at">children =</span> <span class="fu">list_reverse</span>(children)</span>
<span id="cb30-27"><a href="#cb30-27"></a>    )</span>
<span id="cb30-28"><a href="#cb30-28"></a>  }</span>
<span id="cb30-29"><a href="#cb30-29"></a></span>
<span id="cb30-30"><a href="#cb30-30"></a>  <span class="co"># When Any is encountered, make the preceding token (or subtree)</span></span>
<span id="cb30-31"><a href="#cb30-31"></a>  <span class="co"># the child of the Any token</span></span>
<span id="cb30-32"><a href="#cb30-32"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"Any"</span>) {</span>
<span id="cb30-33"><a href="#cb30-33"></a>    last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb30-34"><a href="#cb30-34"></a>    tree[[<span class="fu">length</span>(tree)]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb30-35"><a href="#cb30-35"></a>      <span class="at">parent =</span> token,</span>
<span id="cb30-36"><a href="#cb30-36"></a>      <span class="at">children =</span> <span class="fu">list</span>(last)</span>
<span id="cb30-37"><a href="#cb30-37"></a>    )</span>
<span id="cb30-38"><a href="#cb30-38"></a>  }</span>
<span id="cb30-39"><a href="#cb30-39"></a></span>
<span id="cb30-40"><a href="#cb30-40"></a>  <span class="co"># When Or is encountered, create a subtree with two children. The</span></span>
<span id="cb30-41"><a href="#cb30-41"></a>  <span class="co"># first (or left) child is taken by moving it from the previous</span></span>
<span id="cb30-42"><a href="#cb30-42"></a>  <span class="co"># token/subtree in our list. The second child is tagged as "Missing"</span></span>
<span id="cb30-43"><a href="#cb30-43"></a>  <span class="co"># and will be filled in later</span></span>
<span id="cb30-44"><a href="#cb30-44"></a>  <span class="cf">if</span> (token<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"Or"</span>) {</span>
<span id="cb30-45"><a href="#cb30-45"></a>    last <span class="ot">&lt;-</span> tree[[<span class="fu">length</span>(tree)]]</span>
<span id="cb30-46"><a href="#cb30-46"></a>    tree[[<span class="fu">length</span>(tree)]] <span class="ot">&lt;-</span> <span class="fu">subtree</span>(</span>
<span id="cb30-47"><a href="#cb30-47"></a>      <span class="at">parent =</span> token,</span>
<span id="cb30-48"><a href="#cb30-48"></a>      <span class="at">children =</span> <span class="fu">list</span>(last, <span class="fu">subtree</span>(<span class="fu">token</span>(<span class="at">kind =</span> <span class="st">"Missing"</span>, <span class="at">loc =</span> <span class="dv">0</span>)))</span>
<span id="cb30-49"><a href="#cb30-49"></a>    )</span>
<span id="cb30-50"><a href="#cb30-50"></a>  }</span>
<span id="cb30-51"><a href="#cb30-51"></a></span>
<span id="cb30-52"><a href="#cb30-52"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb30-53"><a href="#cb30-53"></a>}</span>
<span id="cb30-54"><a href="#cb30-54"></a></span>
<span id="cb30-55"><a href="#cb30-55"></a>has_children <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb30-56"><a href="#cb30-56"></a>  <span class="sc">!</span><span class="fu">is.null</span>(x<span class="sc">$</span>children) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(x<span class="sc">$</span>children) <span class="sc">&gt;</span> <span class="dv">0</span></span>
<span id="cb30-57"><a href="#cb30-57"></a>}</span>
<span id="cb30-58"><a href="#cb30-58"></a></span>
<span id="cb30-59"><a href="#cb30-59"></a>compress_or_skip <span class="ot">&lt;-</span> <span class="cf">function</span>(tree, location) {</span>
<span id="cb30-60"><a href="#cb30-60"></a>  <span class="cf">if</span> (<span class="fu">has_children</span>(tree[[location <span class="sc">-</span> <span class="dv">1</span>]])) {</span>
<span id="cb30-61"><a href="#cb30-61"></a>    n <span class="ot">&lt;-</span> <span class="fu">length</span>(tree[[location <span class="sc">-</span> <span class="dv">1</span>]]<span class="sc">$</span>children)</span>
<span id="cb30-62"><a href="#cb30-62"></a>    <span class="cf">if</span> (tree[[location <span class="sc">-</span> <span class="dv">1</span>]]<span class="sc">$</span>children[[n]]<span class="sc">$</span>parent<span class="sc">$</span>kind <span class="sc">==</span> <span class="st">"Missing"</span>) {</span>
<span id="cb30-63"><a href="#cb30-63"></a>      tree[[location <span class="sc">-</span> <span class="dv">1</span>]]<span class="sc">$</span>children[[n]] <span class="ot">&lt;-</span> tree[[location]]</span>
<span id="cb30-64"><a href="#cb30-64"></a>      tree[[location]] <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb30-65"><a href="#cb30-65"></a>    }</span>
<span id="cb30-66"><a href="#cb30-66"></a>  }</span>
<span id="cb30-67"><a href="#cb30-67"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb30-68"><a href="#cb30-68"></a>}</span>
<span id="cb30-69"><a href="#cb30-69"></a></span>
<span id="cb30-70"><a href="#cb30-70"></a>compress_tree <span class="ot">&lt;-</span> <span class="cf">function</span>(tree) {</span>
<span id="cb30-71"><a href="#cb30-71"></a>  <span class="cf">if</span> (<span class="fu">length</span>(tree) <span class="sc">&lt;=</span> <span class="dv">1</span>) {</span>
<span id="cb30-72"><a href="#cb30-72"></a>    <span class="fu">return</span>(tree)</span>
<span id="cb30-73"><a href="#cb30-73"></a>  }</span>
<span id="cb30-74"><a href="#cb30-74"></a></span>
<span id="cb30-75"><a href="#cb30-75"></a>  <span class="co"># Compress branches of the top-level tree</span></span>
<span id="cb30-76"><a href="#cb30-76"></a>  loc <span class="ot">&lt;-</span> <span class="fu">length</span>(tree)</span>
<span id="cb30-77"><a href="#cb30-77"></a>  <span class="cf">while</span> (loc <span class="sc">&gt;</span> <span class="dv">1</span>) {</span>
<span id="cb30-78"><a href="#cb30-78"></a>    tree <span class="ot">&lt;-</span> <span class="fu">compress_or_skip</span>(tree, loc)</span>
<span id="cb30-79"><a href="#cb30-79"></a>    loc <span class="ot">&lt;-</span> loc <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb30-80"><a href="#cb30-80"></a>  }</span>
<span id="cb30-81"><a href="#cb30-81"></a></span>
<span id="cb30-82"><a href="#cb30-82"></a>  <span class="co"># Recursively compress branches of children subtrees</span></span>
<span id="cb30-83"><a href="#cb30-83"></a>  <span class="cf">for</span> (loc <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(tree)) {</span>
<span id="cb30-84"><a href="#cb30-84"></a>    tree[[loc]]<span class="sc">$</span>children <span class="ot">&lt;-</span> <span class="fu">compress_tree</span>(tree[[loc]]<span class="sc">$</span>children)</span>
<span id="cb30-85"><a href="#cb30-85"></a>  }</span>
<span id="cb30-86"><a href="#cb30-86"></a></span>
<span id="cb30-87"><a href="#cb30-87"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb30-88"><a href="#cb30-88"></a>}</span>
<span id="cb30-89"><a href="#cb30-89"></a></span>
<span id="cb30-90"><a href="#cb30-90"></a>parse <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb30-91"><a href="#cb30-91"></a>  tree <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb30-92"><a href="#cb30-92"></a>  tokens <span class="ot">&lt;-</span> <span class="fu">tokenize</span>(text)</span>
<span id="cb30-93"><a href="#cb30-93"></a>  <span class="cf">for</span>(token <span class="cf">in</span> tokens) {</span>
<span id="cb30-94"><a href="#cb30-94"></a>    tree <span class="ot">&lt;-</span> <span class="fu">update_tree</span>(tree, token)</span>
<span id="cb30-95"><a href="#cb30-95"></a>  }</span>
<span id="cb30-96"><a href="#cb30-96"></a>  tree <span class="ot">&lt;-</span> <span class="fu">compress_tree</span>(tree)</span>
<span id="cb30-97"><a href="#cb30-97"></a>  <span class="fu">class</span>(tree) <span class="ot">&lt;-</span> <span class="st">"token_list"</span> <span class="co"># allows pretty printing</span></span>
<span id="cb30-98"><a href="#cb30-98"></a>  <span class="fu">return</span>(tree)</span>
<span id="cb30-99"><a href="#cb30-99"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<p>For expressions that don’t have an <code>Or</code> token, the output is the same as before:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"^caa*t$"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Start
&lt;Token at 2&gt; Literal: c
&lt;Token at 3&gt; Literal: a
&lt;Token at 5&gt; Any
     &lt;Token at 4&gt; Literal: a
&lt;Token at 6&gt; Literal: t
&lt;Token at 7&gt; End</code></pre>
</div>
</div>
<p>However, what we see in this version is that the parse tree for expressions like <code>"(cat)|(dog)"</code> now places the right hand side of the either/or expression (i.e., the <code>(dog)</code> group) in the appropriate place:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"(cat)|(dog)"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 6&gt; Or
     &lt;Token at 1&gt; Group
          &lt;Token at 2&gt; Literal: c
          &lt;Token at 3&gt; Literal: a
          &lt;Token at 4&gt; Literal: t
     &lt;Token at 7&gt; Group
          &lt;Token at 8&gt; Literal: d
          &lt;Token at 9&gt; Literal: o
          &lt;Token at 10&gt; Literal: g</code></pre>
</div>
</div>
<p>No more of those “Missing” tokens. And because the <code>compress_tree()</code> function is recursively applied to the subtrees, it can also handle uglier expressions like <code>"ab|((cd*)|ef)|g"</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">parse</span>(<span class="st">"ab|((cd*)|ef)|g"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>&lt;Token at 1&gt; Literal: a
&lt;Token at 3&gt; Or
     &lt;Token at 2&gt; Literal: b
     &lt;Token at 14&gt; Or
          &lt;Token at 4&gt; Group
               &lt;Token at 10&gt; Or
                    &lt;Token at 5&gt; Group
                         &lt;Token at 6&gt; Literal: c
                         &lt;Token at 8&gt; Any
                              &lt;Token at 7&gt; Literal: d
                    &lt;Token at 11&gt; Literal: e
               &lt;Token at 12&gt; Literal: f
          &lt;Token at 15&gt; Literal: g</code></pre>
</div>
</div>
<p>Neat. I mean… the thing itself is ugly as sin, but the fact that an amateur like myself can spend a day or two working through the relevant chapters in the book and write code that can handle parse trees like these ones… yeah, that’s very neat indeed.</p>
</section>
</section>
<section id="final-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="final-thoughts">Final thoughts?</h2>
<p>Back when I was an academic, as opposed to whatever the hell it is I am in my middle aged unemployment era, there was this whole tradition of writing “critical” book reviews that would ostensibly count as scholarly output. This led to this weird thing where you’d read a book and enjoy it, but you’d feel this obligation to write a Proper Academic Review, and like most things in academia that have Prestige Points associated with them, these reviews would be extremely thorough, mind-meltingly boring, and pointlessly cruel. Because that’s what academia is designed to encourage.</p>
<p>Yeah nah. I’m too old for that shit, and I gave up tenure a lifetime<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> ago.</p>
<p>Having read most of the book at a superficial level and done a deep dive into the parts that I felt like diving into, I have to say I rather like <em>Software Design by Example</em>. It’s not written the way I would write a book: anyone who knows me understands that I will never choose to write a 200 page book when I could write a 600 page book instead. Greg Wilson doesn’t write like me: the book is brief, it covers a lot of topics concisely, and yet still manages to convey a lot of the “folk knowledge” and other cultural bits and pieces that actually matter in the wild. Honestly that’s an awfully impressive achievement. I quite enjoyed it.</p>
<p>Totally worth the time I spent reading it. Would recommend to others.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Something that you’d think I’d have been taught back when I was an academic and had to do it for a living. Universities, however, are utterly useless at this kind of thing. They tend to throw professors in the deep end with this expectation that someone who has made a career as a good researcher will automatically work out how to be a good teacher. Suffice it to say, this widespread practice has not been the best thing for higher education.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>As an aside, this is hardly unique to the tech world. Academia is just as bad. Probably worse, actually.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Example: Greg’s code relies heavily on JavaScript <code>.push()</code> and <code>.pop()</code> methods that make it very easy to treat an array as a <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">stack</a>. I’m going to work with R lists that don’t have these little niceties. It’s going to make some of my code later a little ugly, I’m afraid. Oh well.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is not the place for me to talk about my love/hate relationship with the <a href="http://adv-r.had.co.nz/S3.html">S3 object-oriented programming system</a> in R. Suffice it to say, I have <em>feelings</em>. That’s enough for now.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Okay, I’ll be honest, I did have a set of informal tests that I wrote to accompany my code, even for this blog post: I was too lazy to bother writing a proper test suite, but the initial drafts of this blog post had a bunch of regular expressions that would be tokenized/parsed every time I rendered the draft, which let me check that the code I was writing was not “total batshit”. I do have <em>some</em> standards, at least when it comes to code. The same cannot be said of my <a href="https://youtu.be/5QML71sBu1E">taste in men</a>, but that’s a different story…<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Yeah no that will never happen. If you’re waiting for me to attempt something like what Greg has done, then – to quote Paul Kelly and Kev Carmody – <a href="https://youtu.be/dAONlfoNVuY">you don’t stand the chance of a cinder in snow</a>. I know my limits.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>This is analogous to the <code>handle()</code> JavaScript function that appears in the book. What can I say? I’m a perverse woman who likes to use her own names for things.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Two years, but that’s a lifetime in tranny-years. We age fast, you know.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{navarro2023,
  author = {Navarro, Danielle},
  title = {Software Design by Example},
  date = {2023-05-31},
  url = {https://blog.djnavarro.net/posts/2023-05-31_software-design-by-example},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-navarro2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Navarro, Danielle. 2023. <span>“Software Design by Example.”</span> May
31, 2023. <a href="https://blog.djnavarro.net/posts/2023-05-31_software-design-by-example">https://blog.djnavarro.net/posts/2023-05-31_software-design-by-example</a>.
</div></div></section></div></main> <!-- /main -->
<!-- plausible -->
<script async="" defer="" data-domain="blog.djnavarro.net" src="https://plausible.io/js/plausible.js"></script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://blog.djnavarro.net">
<p>blog.djnavarro.net</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>